Index: app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.smrpv2.ui.medicine.medshot;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.os.Bundle;\r\n\r\nimport com.example.smrpv2.R;\r\n\r\npublic class CameraFrontActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_camera_front);\r\n\r\n        if (null == savedInstanceState) {\r\n            getSupportFragmentManager().beginTransaction()\r\n                    .replace(R.id.container, CameraFrontFragment.newInstance())\r\n                    .commit();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontActivity.java	(revision 9884ed4171d8562cb45e945e27cc9b6fbb2a1385)
+++ app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontActivity.java	(date 1607326186989)
@@ -1,6 +1,7 @@
 package com.example.smrpv2.ui.medicine.medshot;
 
 import androidx.appcompat.app.AppCompatActivity;
+import androidx.fragment.app.Fragment;
 
 import android.os.Bundle;
 
@@ -8,15 +9,20 @@
 
 public class CameraFrontActivity extends AppCompatActivity {
 
+    private static Fragment fragment;
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_camera_front);
 
+        fragment = CameraFrontFragment.newInstance();
         if (null == savedInstanceState) {
             getSupportFragmentManager().beginTransaction()
-                    .replace(R.id.container, CameraFrontFragment.newInstance())
+                    .replace(R.id.container,fragment)
                     .commit();
         }
     }
+    public static Fragment getInstance(){
+        return fragment;
+    }
 }
\ No newline at end of file
Index: app/src/main/java/com/example/smrpv2/ui/medicine/medshot/KakaoOCRActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.smrpv2.ui.medicine.medshot;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.drawable.BitmapDrawable;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.media.ExifInterface;\r\nimport android.net.Uri;\r\nimport android.os.Bundle;\r\nimport android.provider.MediaStore;\r\nimport android.util.Log;\r\nimport android.util.SparseBooleanArray;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport com.example.smrpv2.R;\r\n\r\nimport com.example.smrpv2.ml.ShapeModelVer11;\r\n\r\nimport com.example.smrpv2.ml.Splitline;\r\nimport com.example.smrpv2.model.MedicineItem;\r\nimport com.example.smrpv2.model.common.KaKaoResult;\r\nimport com.example.smrpv2.model.common.KakaoDto;\r\nimport com.example.smrpv2.model.Message;\r\nimport com.example.smrpv2.retrofit.RetrofitHelper;\r\nimport com.example.smrpv2.retrofit.RetrofitService_Server;\r\nimport com.example.smrpv2.ui.start.StartActivity;\r\n\r\nimport org.checkerframework.checker.nullness.qual.NonNull;\r\nimport org.tensorflow.lite.DataType;\r\nimport org.tensorflow.lite.support.common.FileUtil;\r\nimport org.tensorflow.lite.support.common.TensorProcessor;\r\nimport org.tensorflow.lite.support.common.ops.DequantizeOp;\r\nimport org.tensorflow.lite.support.common.ops.NormalizeOp;\r\nimport org.tensorflow.lite.support.image.ImageProcessor;\r\nimport org.tensorflow.lite.support.image.TensorImage;\r\nimport org.tensorflow.lite.support.image.ops.ResizeOp;\r\nimport org.tensorflow.lite.support.label.TensorLabel;\r\nimport org.tensorflow.lite.support.tensorbuffer.TensorBuffer;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.StringTokenizer;\r\n\r\nimport okhttp3.MediaType;\r\nimport okhttp3.MultipartBody;\r\nimport okhttp3.RequestBody;\r\nimport retrofit2.Call;\r\nimport retrofit2.Callback;\r\nimport retrofit2.Response;\r\n\r\n\r\n/**\r\n * 수\r\n */\r\npublic class KakaoOCRActivity extends AppCompatActivity implements MedicineResultRecyclerAdapter.OnItemClickListener{\r\n    private Bitmap targetBitmap_front, targetBitmap_back;\r\n    Context context;\r\n\r\n    Call<KakaoDto> call;\r\n    StringBuilder ocr_result = new StringBuilder();\r\n    private EditText frontEditText,backEditText;\r\n    Button btn_confirm;\r\n    ImageView img_front, img_back;\r\n\r\n    ArrayList<String> shape1 = new ArrayList<String>();\r\n    ArrayList<String> front_dividing_line1 = new ArrayList<String>();\r\n    ArrayList<String> back_dividing_line1 = new ArrayList<String>();\r\n    ArrayList<String> color1 = new ArrayList<String>();\r\n\r\n\r\n    RecyclerView Lst_shape= null ;\r\n    RecyclerView Lst_color= null ;\r\n    RecyclerView Lst_front_dividing_line = null ;\r\n    RecyclerView Lst_back_dividing_line = null ;\r\n    ImageView iv_back;\r\n\r\n    MedicineResultRecyclerAdapter adapter_row1 = null ; //색 어댑터\r\n    MedicineResultRecyclerAdapter adapter_row2  = null ; // 모양 어댑터\r\n    MedicineResultRecyclerAdapter adapter_row3  = null ; // 앞 분할선 어댑터\r\n    MedicineResultRecyclerAdapter adapter_row4 = null ; //뒷 분할선 어댑터\r\n\r\n    ArrayList<MedicineItem> list_row1 = new ArrayList<MedicineItem>();\r\n    ArrayList<MedicineItem> list_row2= new ArrayList<MedicineItem>();\r\n    ArrayList<MedicineItem> list_row3 = new ArrayList<MedicineItem>();\r\n    ArrayList<MedicineItem> list_row4 = new ArrayList<MedicineItem>();\r\n\r\n\r\n    private SparseBooleanArray mSelectedItems1 = new SparseBooleanArray(0); //모양\r\n    private SparseBooleanArray mSelectedItems2 = new SparseBooleanArray(0); //색상\r\n    private SparseBooleanArray mSelectedItems3 = new SparseBooleanArray(0); //앞면\r\n    private SparseBooleanArray mSelectedItems4 = new SparseBooleanArray(0); //뒷면\r\n\r\n    private int[] row_images1 = {R.drawable.ic_circle_green,R.drawable.ic_triangle_green, R.drawable.ic_rectangle_green,R.drawable.ic_rhombus_green, R.drawable.ic_oblong_green,R.drawable.ic_oval_green,R.drawable.ic_semicircle_green,R.drawable.ic_pentagon_green,R.drawable.ic_hexagon_green,R.drawable.ic_octagon_green,R.drawable.ic_etc_green};\r\n    private int[] row_images2 = {R.drawable.ic_white_green,R.drawable.ic_yellow_green,R.drawable.ic_orange_green,R.drawable.ic_pink_green,R.drawable.ic_red_green,R.drawable.ic_brown_green,R.drawable.ic_yellowgreen_green, R.drawable.ic_purple_green,R.drawable.ic_bluegreen_green,R.drawable.ic_blue_green,R.drawable.ic_navy_green,R.drawable.ic_redviolet_green,R.drawable.ic_gray_green,R.drawable.ic_black_green};\r\n    private int[] row_images3 = {R.drawable.ic_empty_green,R.drawable.ic_line_minus_green,R.drawable.ic_line_pluse_green, R.drawable.ic_line_etc_green};\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_kakao_ocr);//activity_search_prescription\r\n\r\n        String frontImg = getIntent().getStringExtra(\"frontImg\");\r\n        String backImg = getIntent().getStringExtra(\"backImg\");\r\n        assert frontImg != null;\r\n        Log.d(\"gggg\", frontImg);\r\n        assert backImg != null;\r\n        Log.d(\"gggg\", backImg);\r\n        String frontImgDate = backImg.substring(0, frontImg.lastIndexOf(\"/\")) + \"/picF.jpg\"; //앞면이미지\r\n        String backImgDate = backImg.substring(0, backImg.lastIndexOf(\"/\")) + \"/picB.jpg\"; //뒷면이미지\r\n\r\n\r\n        init();\r\n        context = this;\r\n        Log.d(\"TAG\", \"frontImg: \" + frontImgDate);\r\n        Log.d(\"TAG\", \"backImg: \" + backImgDate);\r\n          /*  D/gggg: /storage/emulated/0/Android/data/com.example.smrpv2/files/picF.jpg\r\n            D/gggg: /storage/emulated/0/Android/data/com.example.smrpv2/files/picB.jpg\r\n            D/TAG: frontImg: /storage/emulated/0/Android/data/com.example.smrpv2/files/picF.jpg\r\n            backImg: /storage/emulated/0/Android/data/com.example.smrpv2/files/picB.jpg*/\r\n\r\n\r\n        btn_confirm.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                if (checkItem()) {\r\n                    Intent intent = new Intent(context, CameraResultActivity.class);\r\n\r\n                    String frontText = frontEditText.getText().toString();\r\n                    String backText = backEditText.getText().toString();\r\n                    String color = \"\";\r\n                    String shape = \"\";\r\n                    String frontDividing = \"\";\r\n                    String backDividing = \"\";\r\n                    for (int i = 0; i < mSelectedItems1.size(); i++) {\r\n                        if (mSelectedItems1.get(i) == true) {\r\n                            shape = list_row1.get(i).getText();\r\n                            Log.d(\"kakoActivity\", \"shape: \" + shape);\r\n                            break;\r\n                        }\r\n                    }\r\n                    for (int i = 0; i < mSelectedItems2.size(); i++) {\r\n                        if (mSelectedItems2.get(i) == true) {\r\n                            color = list_row2.get(i).getText();\r\n                            Log.d(\"kakoActivity\", \"color: \" + color);\r\n                            break;\r\n                        }\r\n                    }\r\n                    for (int i = 0; i < mSelectedItems3.size(); i++) {\r\n                        if (mSelectedItems3.get(i) == true) {\r\n                            frontDividing = list_row3.get(i).getText();\r\n                            Log.d(\"kakoActivity\", \"frontDividing: \" + frontDividing);\r\n                            break;\r\n                        }\r\n                    }\r\n                    for (int i = 0; i < mSelectedItems4.size(); i++) {\r\n                        if (mSelectedItems4.get(i) == true) {\r\n                            backDividing = list_row4.get(i).getText();\r\n                            Log.d(\"kakoActivity\", \"backDividing: \" + backDividing);\r\n                            break;\r\n                        }\r\n                    }\r\n                /*String color = color1.get(0);\r\n                String shape = shape1.get(0);\r\n                String frontDividing = front_dividing_line1.get(0);\r\n                String backDividing = back_dividing_line1.get(0);*/\r\n\r\n                    intent.putExtra(\"frontText\", frontText);\r\n                    intent.putExtra(\"backText\", backText);\r\n                    intent.putExtra(\"color\", color);\r\n                    intent.putExtra(\"shape\", shape);\r\n                    intent.putExtra(\"frontDividing\", frontDividing);\r\n                    intent.putExtra(\"backDividing\", backDividing);\r\n                    Log.d(\"total\", \"total: \"+frontText+\",\"+backText+\",\"+color+\",\"+shape+\",\"+frontDividing+\",\"+backDividing);\r\n                    startActivity(intent);\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n\r\n\r\n        Bitmap rotatedBitmap = null;\r\n\r\n\r\n\r\n\r\n        try {\r\n            File frontfile = new File(frontImg);\r\n            File backfile = new File(backImg);\r\n\r\n            Bitmap frontbitmap = MediaStore.Images.Media\r\n                    .getBitmap(getContentResolver(), Uri.fromFile(frontfile));\r\n\r\n            Bitmap backbitmap = MediaStore.Images.Media\r\n                    .getBitmap(getContentResolver(), Uri.fromFile(backfile));\r\n\r\n            if (frontbitmap != null) {\r\n                ExifInterface ei = new ExifInterface(frontImg);\r\n                int front_orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION,\r\n                        ExifInterface.ORIENTATION_UNDEFINED);\r\n                switch (front_orientation) {\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_90:\r\n                        rotatedBitmap = rotateImage(frontbitmap, 90);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_180:\r\n                        rotatedBitmap = rotateImage(frontbitmap, 180);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_270:\r\n                        rotatedBitmap = rotateImage(frontbitmap, 270);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_NORMAL:\r\n                    default:\r\n                        rotatedBitmap = frontbitmap;\r\n                }\r\n\r\n            }\r\n\r\n\r\n            targetBitmap_front = Bitmap.createBitmap(rotatedBitmap, rotatedBitmap.getWidth() / 2 - 112, rotatedBitmap.getHeight() / 2 - 112, 224, 224);\r\n\r\n\r\n\r\n            if (backbitmap != null) {\r\n                ExifInterface ei = new ExifInterface(backImg);\r\n                int back_orientation = ei.getAttributeInt(ExifInterface.TAG_ORIENTATION,\r\n                        ExifInterface.ORIENTATION_UNDEFINED);\r\n                switch (back_orientation) {\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_90:\r\n                        rotatedBitmap = rotateImage(backbitmap, 90);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_180:\r\n                        rotatedBitmap = rotateImage(backbitmap, 180);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_ROTATE_270:\r\n                        rotatedBitmap = rotateImage(backbitmap, 270);\r\n                        break;\r\n\r\n                    case ExifInterface.ORIENTATION_NORMAL:\r\n                    default:\r\n                        rotatedBitmap = backbitmap;\r\n                }\r\n\r\n            }\r\n            targetBitmap_back = Bitmap.createBitmap(rotatedBitmap, rotatedBitmap.getWidth() / 2 - 112, rotatedBitmap.getHeight() / 2 - 112, 224, 224);\r\n            Log.d(\"하기전\", frontfile.toString());\r\n            Log.d(\"하기전\", backfile.toString());\r\n            SaveBitmapToFileCache(targetBitmap_front, frontImgDate);\r\n            SaveBitmapToFileCache(targetBitmap_back, backImgDate);\r\n            Log.d(\"한후\", frontfile.toString());\r\n            Log.d(\"한후\", backfile.toString());\r\n\r\n\r\n            //카카오 OCR\r\n            sendKakaoOcr(frontfile, backfile, true); // 카카오 ocr 서버 전송(앞면 뒷면 사진)\r\n\r\n\r\n            sendFile(frontfile, backfile);\r\n            img_front.setImageBitmap(targetBitmap_front);\r\n            img_back.setImageBitmap(targetBitmap_back);\r\n\r\n            useModel(targetBitmap_front);\r\n\r\n\r\n            useDividingModel(targetBitmap_front,\"앞\");\r\n            useDividingModel(targetBitmap_back,\"뒤\");\r\n        } catch (Exception err) {\r\n            err.printStackTrace();\r\n        }\r\n        iv_back.setOnClickListener(new View.OnClickListener() {\r\n            @Override\r\n            public void onClick(View v) {\r\n                onBackPressed();\r\n            }\r\n        });\r\n\r\n\r\n        //  Uploading_bitmap_front(targetBitmap_front);\r\n\r\n    }\r\n\r\n    private void useDividingModel(Bitmap bitmap,String string) {\r\n        try {\r\n            ImageProcessor imageProcessor =\r\n                    new ImageProcessor.Builder()\r\n                            .add(new ResizeOp(224, 224, ResizeOp.ResizeMethod.BILINEAR))\r\n                            .build();\r\n\r\n           Splitline model = Splitline.newInstance(this);\r\n\r\n\r\n            // Creates inputs for reference.\r\n\r\n            //Drawable drawable = getDrawable(R.drawable.image8);\r\n\r\n            // Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap();\r\n\r\n            ByteBuffer buffer = ByteBuffer.allocate(bitmap.getByteCount()); //바이트 버퍼를 이미지 사이즈 만큼 선언\r\n\r\n            bitmap.copyPixelsToBuffer(buffer);//비트맵의 픽셀을 버퍼에 저장\r\n\r\n            //\r\n            TensorBuffer inputI = TensorBuffer.createFixedSize(new int[]{1, 224, 224, 3}, DataType.FLOAT32);\r\n\r\n\r\n            TensorImage tImage = new TensorImage(DataType.FLOAT32);\r\n\r\n\r\n            tImage.load(bitmap);\r\n            tImage = imageProcessor.process(tImage);\r\n\r\n\r\n            TensorProcessor probabilityProcessor =\r\n                    new TensorProcessor.Builder().add(new DequantizeOp(0, 1 / 255.0f)).build();\r\n\r\n\r\n            TensorBuffer inputFeature0 = TensorBuffer.createFixedSize(new int[]{1, 224, 224, 3}, DataType.FLOAT32);\r\n\r\n\r\n            inputFeature0.loadBuffer(tImage.getBuffer());\r\n            TensorBuffer dequantizedBuffer = probabilityProcessor.process(inputFeature0);\r\n\r\n\r\n            // Runs model inference and gets result.\r\n            Splitline.Outputs outputs = model.process(dequantizedBuffer);\r\n            TensorBuffer probabilityBuffer =\r\n                    TensorBuffer.createFixedSize(new int[]{1, 20}, DataType.FLOAT32);\r\n            probabilityBuffer = outputs.getOutputFeature0AsTensorBuffer();\r\n\r\n            @NonNull float[] floatArray = probabilityBuffer.getFloatArray();\r\n\r\n            float tempA = 0;\r\n            int idxA = 0;\r\n\r\n            float tempB = 0;\r\n            int idxB = 0;\r\n\r\n            float tempC = 0;\r\n            int idxC = 0;\r\n            for (int i = 0; i < floatArray.length; i++) {\r\n                if (floatArray[i] > tempA) {\r\n                    tempA = floatArray[i];\r\n                    idxA = i;\r\n                } else if (floatArray[i] > tempB) {\r\n                    tempB = floatArray[i];\r\n                    idxB = i;\r\n                } else if (floatArray[i] > tempC) {\r\n                    tempC = floatArray[i];\r\n                    idxC = i;\r\n                }\r\n            }\r\n\r\n            Log.d(\"idx처음 :\", idxA + \"   \" + tempA);\r\n            final String ASSOCIATED_AXIS_LABELS = \"split.txt\";\r\n            List<String> associatedAxisLabels = null;\r\n\r\n            try {\r\n                associatedAxisLabels = FileUtil.loadLabels(this, ASSOCIATED_AXIS_LABELS);\r\n            } catch (IOException e) {\r\n                Log.e(\"tfliteSupport\", \"Error reading label file\", e);\r\n            }\r\n\r\n            String ttt = associatedAxisLabels.get(idxA) + tempA + associatedAxisLabels.get(idxB) + tempB + associatedAxisLabels.get(idxC) + tempC;\r\n\r\n\r\n            String s = associatedAxisLabels.get(idxA);\r\n        //    editText.setText(s);\r\n            Log.d(\"gg:\", associatedAxisLabels.get(idxA));\r\n            // Releases model resources if no longer used.\r\n\r\n\r\n\r\n\r\n\r\n            //분류작업\r\n            String dividing = associatedAxisLabels.get(idxA);\r\n\r\n            int i;\r\n\r\n            for(i=0; i < list_row3.size();i++){\r\n                if(list_row3.get(i).getText().contains(dividing))\r\n                    break;\r\n            }\r\n\r\n\r\n\r\n\r\n            LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\r\n\r\n\r\n\r\n\r\n\r\n\r\n            if(string.contains(\"앞\")){\r\n                Log.d(\"ggg\",\"앞\"+i);\r\n                adapter_row3  = new MedicineResultRecyclerAdapter(list_row3,this, Lst_front_dividing_line,4,row_images3,i) ;\r\n                Lst_front_dividing_line.setLayoutManager(layoutManager) ;\r\n                Lst_front_dividing_line.setAdapter(adapter_row3);\r\n                Lst_front_dividing_line.getItemAnimator().setChangeDuration(0);\r\n                Lst_front_dividing_line.getAdapter().notifyDataSetChanged();\r\n\r\n            }else{\r\n                Log.d(\"kkk\",\"뒤\"+i);\r\n                adapter_row4  = new MedicineResultRecyclerAdapter(list_row4,this, Lst_back_dividing_line,4,row_images3,i) ;\r\n                Lst_back_dividing_line.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)) ;\r\n                Lst_back_dividing_line.setAdapter(adapter_row4);\r\n                Lst_back_dividing_line.getItemAnimator().setChangeDuration(0);\r\n                Lst_back_dividing_line.getAdapter().notifyDataSetChanged();\r\n            }\r\n\r\n\r\n\r\n\r\n\r\n            TensorProcessor probabilityProcessor1 =\r\n                    new TensorProcessor.Builder().add(new NormalizeOp(0, 20)).build();\r\n\r\n            if (null != associatedAxisLabels) {\r\n                // Map of labels and their corresponding probability\r\n                TensorLabel labels = new TensorLabel(associatedAxisLabels,\r\n                        probabilityProcessor1.process(probabilityBuffer));\r\n\r\n                // Create a map to access the result based on label\r\n                Map<String, Float> floatMap = labels.getMapWithFloatValue();\r\n\r\n            }\r\n            model.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    private void useModel(Bitmap bitmap) { // 이미지 모양 모델\r\n        try {\r\n            ImageProcessor imageProcessor =\r\n                    new ImageProcessor.Builder()\r\n                            .add(new ResizeOp(224, 224, ResizeOp.ResizeMethod.BILINEAR))\r\n                            .build();\r\n\r\n            ShapeModelVer11 model = ShapeModelVer11.newInstance(context);\r\n\r\n\r\n            // Creates inputs for reference.\r\n\r\n            //Drawable drawable = getDrawable(R.drawable.image8);\r\n\r\n            // Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap();\r\n\r\n            ByteBuffer buffer = ByteBuffer.allocate(bitmap.getByteCount()); //바이트 버퍼를 이미지 사이즈 만큼 선언\r\n\r\n            bitmap.copyPixelsToBuffer(buffer);//비트맵의 픽셀을 버퍼에 저장\r\n\r\n            //\r\n            TensorBuffer inputI = TensorBuffer.createFixedSize(new int[]{1, 224, 224, 3}, DataType.FLOAT32);\r\n\r\n\r\n            TensorImage tImage = new TensorImage(DataType.FLOAT32);\r\n\r\n\r\n            tImage.load(bitmap);\r\n            tImage = imageProcessor.process(tImage);\r\n\r\n\r\n            TensorProcessor probabilityProcessor =\r\n                    new TensorProcessor.Builder().add(new DequantizeOp(0, 1 / 255.0f)).build();\r\n\r\n\r\n            TensorBuffer inputFeature0 = TensorBuffer.createFixedSize(new int[]{1, 224, 224, 3}, DataType.FLOAT32);\r\n\r\n\r\n            inputFeature0.loadBuffer(tImage.getBuffer());\r\n            TensorBuffer dequantizedBuffer = probabilityProcessor.process(inputFeature0);\r\n\r\n\r\n            // Runs model inference and gets result.\r\n            ShapeModelVer11.Outputs outputs = model.process(dequantizedBuffer);\r\n            TensorBuffer probabilityBuffer =\r\n                    TensorBuffer.createFixedSize(new int[]{1, 20}, DataType.FLOAT32);\r\n            probabilityBuffer = outputs.getOutputFeature0AsTensorBuffer();\r\n\r\n            @NonNull float[] floatArray = probabilityBuffer.getFloatArray();\r\n\r\n            float tempA = 0;\r\n            int idxA = 0;\r\n\r\n            float tempB = 0;\r\n            int idxB = 0;\r\n\r\n            float tempC = 0;\r\n            int idxC = 0;\r\n            for (int i = 0; i < floatArray.length; i++) {\r\n                if (floatArray[i] > tempA) {\r\n                    tempA = floatArray[i];\r\n                    idxA = i;\r\n                } else if (floatArray[i] > tempB) {\r\n                    tempB = floatArray[i];\r\n                    idxB = i;\r\n                } else if (floatArray[i] > tempC) {\r\n                    tempC = floatArray[i];\r\n                    idxC = i;\r\n                }\r\n            }\r\n\r\n            Log.d(\"idx처음 :\", idxA + \"   \" + tempA);\r\n            final String ASSOCIATED_AXIS_LABELS = \"label.txt\";\r\n            List<String> associatedAxisLabels = null;\r\n\r\n            try {\r\n                associatedAxisLabels = FileUtil.loadLabels(this, ASSOCIATED_AXIS_LABELS);\r\n            } catch (IOException e) {\r\n                Log.e(\"tfliteSupport\", \"Error reading label file\", e);\r\n            }\r\n\r\n            String ttt = associatedAxisLabels.get(idxA) + tempA + associatedAxisLabels.get(idxB) + tempB + associatedAxisLabels.get(idxC) + tempC;\r\n\r\n\r\n\r\n           // shaEditText.setText(associatedAxisLabels.get(idxA));\r\n            Log.d(\"gg:\", associatedAxisLabels.get(idxA));\r\n            // Releases model resources if no longer used.\r\n\r\n\r\n\r\n\r\n\r\n            //\r\n            String str_shape = associatedAxisLabels.get(idxA);\r\n            StringTokenizer st = new StringTokenizer(str_shape, \"형\",true);\r\n            str_shape = st.nextToken();\r\n\r\n            Log.d(\"str_shape\", str_shape);\r\n            int i;\r\n\r\n            for(i=0; i < list_row1.size();i++){\r\n                Log.d(\"aaa\", list_row1.get(i).getText());\r\n                if(list_row1.get(i).getText().contains(str_shape))\r\n                    break;\r\n            }\r\n\r\n            if(i==list_row1.size()){\r\n                i=10;\r\n            }else{\r\n                Log.d(\"lst\", list_row1.get(i).getText());\r\n\r\n                Log.d(\"lst\", list_row1.get(i).getText());\r\n            }\r\n\r\n            //itemView.performClick()\r\n\r\n\r\n           // adapter_row1.setStatus(list_row1.get(i).getText());\r\n\r\n\r\n           /*adapter_row1.click.onClick(Lst_shape.getChildAt(i));*/\r\n\r\n            LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\r\n            adapter_row1  = new MedicineResultRecyclerAdapter(list_row1,this, Lst_shape,11, row_images1,i) ;\r\n\r\n            Lst_shape .setLayoutManager(layoutManager ) ;\r\n            Lst_shape .setAdapter(adapter_row1);\r\n            Lst_shape.getItemAnimator().setChangeDuration(0);\r\n            Lst_shape.getAdapter().notifyDataSetChanged();\r\n           // adapter_row1.getmListener().onClick();\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            TensorProcessor probabilityProcessor1 =\r\n                    new TensorProcessor.Builder().add(new NormalizeOp(0, 20)).build();\r\n\r\n            if (null != associatedAxisLabels) {\r\n                // Map of labels and their corresponding probability\r\n                TensorLabel labels = new TensorLabel(associatedAxisLabels,\r\n                        probabilityProcessor1.process(probabilityBuffer));\r\n\r\n                // Create a map to access the result based on label\r\n                Map<String, Float> floatMap = labels.getMapWithFloatValue();\r\n\r\n            }\r\n            model.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    private void sendKakaoOcr(File frontImage, File backImage, boolean status) {\r\n        //int count = flag;\r\n        if (status) {\r\n            RequestBody body = RequestBody.create(MediaType.parse(\"image/*\"), frontImage);\r\n            ///storage/emulated/0/Android/data/com.example.smrpv2/files/picF.jpg\r\n            MultipartBody.Part fPart = MultipartBody.Part.createFormData(\"image\", \"front.jpg\", body);\r\n            call = RetrofitHelper.getKaKaoOcr().create(RetrofitService_Server.class).sendKakaoOcr(fPart);\r\n        } else {\r\n            RequestBody body = RequestBody.create(MediaType.parse(\"image/*\"), backImage);\r\n            MultipartBody.Part bPart = MultipartBody.Part.createFormData(\"image\", \"back.jpg\", body);\r\n            call = RetrofitHelper.getKaKaoOcr().create(RetrofitService_Server.class).sendKakaoOcr(bPart);\r\n        }\r\n\r\n        call.enqueue(new Callback<KakaoDto>() {\r\n            @Override\r\n            public void onResponse(Call<KakaoDto> call, Response<KakaoDto> response) {\r\n\r\n                for (int i = 0; i < response.body().getResult().size(); i++) {\r\n                    KaKaoResult kaKaoResult = response.body().getResult().get(i);\r\n                    for (int j = 0; j < kaKaoResult.getRecognition_words().length; j++) {\r\n                        Log.d(\"OCR\", kaKaoResult.getRecognition_words()[j]);\r\n                        ocr_result.append(kaKaoResult.getRecognition_words()[j]);\r\n                    }\r\n\r\n                }\r\n\r\n                //ocr_result.append(\"/\");\r\n                if (status) {\r\n                    Log.d(\"TAG\", \"onResponse: \"+status);\r\n                    frontEditText.setText(ocr_result.toString());\r\n                    ocr_result.setLength(0);\r\n                    sendKakaoOcr(frontImage, backImage, false);\r\n\r\n                }else\r\n                    backEditText.setText(ocr_result.toString());\r\n                Log.d(\"TAG\", \"onResponse: \"+status);\r\n                Log.d(\"TAG\", \"result_result: \"+ ocr_result.toString());\r\n\r\n\r\n\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<KakaoDto> call, Throwable t) {\r\n                Log.d(\"실패카카오\", t.toString());\r\n            }\r\n        });\r\n\r\n    }\r\n    private void sendFile (File frontfile, File backfile){ //구축서버에 이미지 파일 전송\r\n\r\n\r\n        ArrayList<MultipartBody.Part> list = new ArrayList<>();\r\n        RequestBody body = RequestBody.create(MediaType.parse(\"image/*\"), frontfile);\r\n        RequestBody body2 = RequestBody.create(MediaType.parse(\"image/*\"), backfile);\r\n        MultipartBody.Part fPart = MultipartBody.Part.createFormData(\"files\", \"front.jpg\", body);\r\n        MultipartBody.Part bPart = MultipartBody.Part.createFormData(\"files\", \"back.jpg\", body2);\r\n        list.add(fPart);\r\n        list.add(bPart);\r\n\r\n        Call<Message> call = RetrofitHelper.getRetrofitService_server().uploadImage(list);\r\n        call.enqueue(new Callback<Message>() {\r\n            @Override\r\n            public void onResponse(Call<Message> call, Response<Message> response) {\r\n                Log.d(\"sendFile\", \"성공\");\r\n                Log.d(\"sendFile\", response.toString());\r\n\r\n\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(Call<Message> call, Throwable t) {\r\n                Log.d(\"sendFile T:\", t.toString());\r\n            }\r\n        });\r\n    }\r\n    private void SaveBitmapToFileCache (Bitmap targetBitmap_front, String frontImgDate){\r\n\r\n        File fileCacheItem = new File(frontImgDate);\r\n\r\n        OutputStream out = null;\r\n\r\n        try {\r\n            fileCacheItem.createNewFile();\r\n            out = new FileOutputStream(fileCacheItem);\r\n            targetBitmap_front.compress(Bitmap.CompressFormat.JPEG, 100, out);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                out.close();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    public static Bitmap rotateImage (Bitmap source,float angle){\r\n        Matrix matrix = new Matrix();\r\n        matrix.postRotate(angle);\r\n        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(),\r\n                matrix, true);\r\n    }\r\n    private void init(){\r\n        img_front = findViewById(R.id.img_front);\r\n        img_back = findViewById(R.id.img_back);\r\n        frontEditText = findViewById(R.id.frontOcrEditText);\r\n        backEditText = findViewById(R.id.backOcrEditText);\r\n        btn_confirm = findViewById(R.id.btn_confirm);\r\n        iv_back = findViewById(R.id.iv_back);\r\n\r\n        Lst_shape = findViewById(R.id.Lst_shape);\r\n        Lst_color = findViewById(R.id.Lst_color);\r\n        Lst_front_dividing_line = findViewById(R.id.Lst_front_dividing_line);\r\n        Lst_back_dividing_line = findViewById(R.id.Lst_back_dividing_line);\r\n\r\n        shape1.add(\"원형\");\r\n        color1.add(\"흰색\");\r\n        front_dividing_line1.add(\"민무늬\");\r\n        back_dividing_line1.add(\"민무늬\");\r\n\r\n        LinearLayoutManager layoutManager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);\r\n\r\n\r\n        adapter_row2  = new MedicineResultRecyclerAdapter(list_row2,this, Lst_color,14,row_images2,0) ;\r\n\r\n        addList();\r\n\r\n\r\n\r\n        Lst_color .setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)) ;\r\n        Lst_color .setAdapter(adapter_row2);\r\n\r\n\r\n\r\n       // shaEditText = findViewById(R.id.shapeEditText);\r\n       // frontLineEditText = findViewById(R.id.et_line_front_dividing);\r\n       // backLineEditText = findViewById(R.id.et_line_back_dividing);\r\n    }\r\n    public void addItem(ArrayList<MedicineItem> list, Drawable icon, String n, int v, String t) {\r\n        MedicineItem item = new MedicineItem();\r\n        item.setIcon(icon); //아이콘\r\n        item.setName(n); //이름\r\n        item.setViewType(v);\r\n        item.setText(t); //\r\n        list.add(item);\r\n        Log.e(\"DD\",\"5555\");\r\n    }\r\n    @Override\r\n    public void onItemClick(View v, int position, RecyclerView rList) {\r\n\r\n\r\n        MedicineItem item;\r\n        switch(rList.getId()){\r\n\r\n            case R.id.Lst_shape : {\r\n                Log.d(\"position\", position+\"\");\r\n                item= list_row1.get(position) ;\r\n                checkSelectedItem(position,mSelectedItems1, item, shape1, list_row1);\r\n                break;\r\n            }\r\n            case R.id.Lst_color : {\r\n                item= list_row2.get(position);\r\n                checkSelectedItem(position,mSelectedItems2, item, color1, list_row2);\r\n                break;\r\n            }\r\n            case R.id.Lst_front_dividing_line: {\r\n                item= list_row3.get(position) ;\r\n                checkSelectedItem(position,mSelectedItems3, item, front_dividing_line1, list_row3);\r\n                break;\r\n            }\r\n            case R.id.Lst_back_dividing_line : {\r\n                item= list_row4.get(position) ;\r\n                checkSelectedItem(position,mSelectedItems4, item, back_dividing_line1, list_row4);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    void checkSelectedItem(int position, SparseBooleanArray mSelectedItems, MedicineItem item, ArrayList<String> type, ArrayList<MedicineItem> list_row){\r\n\r\n\r\n        if (mSelectedItems.get(position, false) ){\r\n            Log.d(\"checkSelectedItem\", \"position: \"+position);\r\n            mSelectedItems.put(position, false);\r\n        }\r\n        else {\r\n            for (int i = 0; i < mSelectedItems.size(); i++) {\r\n                mSelectedItems.put(i, false);\r\n                Log.d(\"TAG\", \"reset: \");\r\n            }\r\n            mSelectedItems.put(position, true);\r\n\r\n\r\n        }\r\n        for(int i=0; i <mSelectedItems.size(); i++){\r\n            if(i==0)type.clear();\r\n            item = list_row.get(i);\r\n            if(mSelectedItems.get(i,false)){\r\n                type.add(item.getText());\r\n            }\r\n        }\r\n    }\r\n    private void addList(){\r\n\r\n        addItem(list_row1,getDrawable(R.drawable.ic_circle), \"원형\",5,\"원형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_triangle), \"삼각형\",5, \"삼각형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_rectangle), \"사각형\",5,\"사각형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_rhombus), \"마름모\",5,\"마름모형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_oblong), \"장방형\",5,\"장방형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_oval), \"타원형\",5,\"타원형\");\r\n        addItem(list_row1,getDrawable(R.drawable.ic_semicircle), \"반원형\",5,\"반원형\");\r\n\r\n        addItem(list_row1,getDrawable(R.drawable.ic_pentagon), \"오각형\",5,\"오각형\");\r\n\r\n        addItem(list_row1,getDrawable(R.drawable.ic_hexagon), \"육각형\",5,\"육각형\");\r\n\r\n        addItem(list_row1,getDrawable(R.drawable.ic_octagon), \"팔각형\",5,\"팔각형\");\r\n\r\n\r\n        addItem(list_row1,getDrawable(R.drawable.ic_etc), \"기타\",5,\"기타\");\r\n\r\n        //list_row2 - 색상\r\n        addItem(list_row2,getDrawable(R.drawable.ic_white), \"하양\",5, \"하양\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_yellow), \"노랑\",5,\"노랑\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_orange), \"주황\",5,\"주황\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_pink), \"분홍\",5,\"분홍\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_red), \"빨강\",5,\"빨강\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_brown), \"갈색\",5,\"갈색\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_yellowgreen), \"연두\",5,\"연두\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_purple), \"보라\",5,\"보라\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_bluegreen), \"청록\",5,\"청록\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_blue), \"파랑\",5,\"파랑\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_navy), \"남색\",5,\"남색\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_redviolet), \"자주\",5,\"자주\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_gray), \"회색\",5,\"회색\");\r\n        addItem(list_row2,getDrawable(R.drawable.ic_black), \"검정\",5,\"검정\");\r\n\r\n        //list_row3 - 앞 분할선\r\n\r\n        addItem(list_row3,getDrawable(R.drawable.ic_empty), \"민무늬\",5,\"민무늬\");\r\n        addItem(list_row3,getDrawable(R.drawable.ic_minus), \"(-)형\",5,\"-\");\r\n        addItem(list_row3,getDrawable(R.drawable.ic_line_plus), \"(+)형\",5,\"+\");\r\n        addItem(list_row3,getDrawable(R.drawable.ic_line_etc), \"문구\",5,\"문구\");\r\n\r\n\r\n        //list_row4 - 뒷 분할선\r\n        addItem(list_row4,getDrawable(R.drawable.ic_empty),\r\n                \"민무늬\",5,\"민무늬\");\r\n        addItem(list_row4,getDrawable(R.drawable.ic_minus),\r\n                \"(-)형\",5,\"-\");\r\n        addItem(list_row4,getDrawable(R.drawable.ic_line_plus),\r\n                \"(+)형\",5,\"+\");\r\n        addItem(list_row4,getDrawable(R.drawable.ic_line_etc),\r\n                \"문구\",5,\"문구\");\r\n\r\n        mSelectedItems1.put(0,true);\r\n        mSelectedItems2.put(0,true);\r\n        mSelectedItems3.put(0,true);\r\n        mSelectedItems4.put(0,true);\r\n        for(int i =1 ; i < 11; i++) mSelectedItems1.put(i,false);\r\n        for(int i =1 ; i < 14; i++) mSelectedItems2.put(i,false);\r\n        for(int i =1 ; i < 4; i++) mSelectedItems3.put(i,false);\r\n        for(int i =1 ; i < 4; i++) mSelectedItems4.put(i,false);\r\n\r\n\r\n        Lst_color.getItemAnimator().setChangeDuration(0);\r\n\r\n\r\n        adapter_row2.notifyDataSetChanged();\r\n\r\n    }\r\n    private boolean checkItem(){\r\n        if(shape1.isEmpty()) {\r\n            Toast.makeText(this,\"모양을 선택해주세요.\",Toast.LENGTH_SHORT).show();\r\n            return false;\r\n        }\r\n        else if(color1.isEmpty()){\r\n            Toast.makeText(this,\"색상을 선택해주세요.\",Toast.LENGTH_SHORT).show();\r\n            return false;\r\n        }\r\n        else if(front_dividing_line1.isEmpty()){\r\n            Toast.makeText(this,\"앞 분할선을 선택해주세요.\",Toast.LENGTH_SHORT).show();\r\n            return false;\r\n        }\r\n        else if(back_dividing_line1.isEmpty()){\r\n            Toast.makeText(this,\"뒷 분할선을 선택해주세요.\",Toast.LENGTH_SHORT).show();\r\n            return false;\r\n        }\r\n        return true;\r\n\r\n\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/smrpv2/ui/medicine/medshot/KakaoOCRActivity.java	(revision 9884ed4171d8562cb45e945e27cc9b6fbb2a1385)
+++ app/src/main/java/com/example/smrpv2/ui/medicine/medshot/KakaoOCRActivity.java	(date 1607326734503)
@@ -1,6 +1,7 @@
 package com.example.smrpv2.ui.medicine.medshot;
 
 import androidx.appcompat.app.AppCompatActivity;
+import androidx.fragment.app.Fragment;
 import androidx.recyclerview.widget.LinearLayoutManager;
 import androidx.recyclerview.widget.RecyclerView;
 
@@ -136,6 +137,9 @@
             backImg: /storage/emulated/0/Android/data/com.example.smrpv2/files/picB.jpg*/
 
 
+
+
+
         btn_confirm.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
Index: app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright 2017 The Android Open Source Project\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage com.example.smrpv2.ui.medicine.medshot;\r\n\r\n\r\nimport android.Manifest;\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.app.Dialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.ImageFormat;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Paint;\r\nimport android.graphics.PixelFormat;\r\nimport android.graphics.Point;\r\nimport android.graphics.PorterDuff;\r\nimport android.graphics.PorterDuffXfermode;\r\nimport android.graphics.RectF;\r\nimport android.graphics.SurfaceTexture;\r\nimport android.hardware.camera2.CameraAccessException;\r\nimport android.hardware.camera2.CameraCaptureSession;\r\nimport android.hardware.camera2.CameraCharacteristics;\r\nimport android.hardware.camera2.CameraDevice;\r\nimport android.hardware.camera2.CameraManager;\r\nimport android.hardware.camera2.CameraMetadata;\r\nimport android.hardware.camera2.CaptureRequest;\r\nimport android.hardware.camera2.CaptureResult;\r\nimport android.hardware.camera2.TotalCaptureResult;\r\nimport android.hardware.camera2.params.StreamConfigurationMap;\r\nimport android.media.Image;\r\nimport android.media.ImageReader;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.HandlerThread;\r\nimport android.util.Log;\r\nimport android.util.Size;\r\nimport android.util.SparseIntArray;\r\nimport android.view.Display;\r\nimport android.view.LayoutInflater;\r\nimport android.view.Surface;\r\nimport android.view.SurfaceHolder;\r\nimport android.view.SurfaceView;\r\nimport android.view.TextureView;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.core.content.ContextCompat;\r\nimport androidx.fragment.app.DialogFragment;\r\nimport androidx.fragment.app.Fragment;\r\n\r\nimport com.example.smrpv2.R;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.Semaphore;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class CameraBackFragment extends Fragment\r\n        implements View.OnClickListener, ActivityCompat.OnRequestPermissionsResultCallback {\r\n\r\n    /**\r\n     * Conversion from screen rotation to JPEG orientation.\r\n     */\r\n    ImageView imageView;\r\n    LinearLayout linearlayout;\r\n    SurfaceView surfaceView;\r\n    int width ;\r\n    int height;\r\n    String frontImg;\r\n    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();\r\n    private static final int REQUEST_CAMERA_PERMISSION = 1;\r\n    private static final String FRAGMENT_DIALOG = \"dialog\";\r\n\r\n    static {\r\n        ORIENTATIONS.append(Surface.ROTATION_0, 90);\r\n        ORIENTATIONS.append(Surface.ROTATION_90, 0);\r\n        ORIENTATIONS.append(Surface.ROTATION_180, 270);\r\n        ORIENTATIONS.append(Surface.ROTATION_270, 180);\r\n    }\r\n\r\n    /**\r\n     * Tag for the {@link Log}.\r\n     */\r\n    private static final String TAG = \"Camera2BasicFragment2\";\r\n\r\n    /**\r\n     * Camera state: Showing camera preview.\r\n     */\r\n    private static final int STATE_PREVIEW = 0;\r\n\r\n    /**\r\n     * Camera state: Waiting for the focus to be locked.\r\n     */\r\n    private static final int STATE_WAITING_LOCK = 1;\r\n\r\n    /**\r\n     * Camera state: Waiting for the exposure to be precapture state.\r\n     */\r\n    private static final int STATE_WAITING_PRECAPTURE = 2;\r\n\r\n    /**\r\n     * Camera state: Waiting for the exposure state to be something other than precapture.\r\n     */\r\n    private static final int STATE_WAITING_NON_PRECAPTURE = 3;\r\n\r\n    /**\r\n     * Camera state: Picture was taken.\r\n     */\r\n    private static final int STATE_PICTURE_TAKEN = 4;\r\n\r\n    /**\r\n     * Max preview width that is guaranteed by Camera2 API\r\n     */\r\n    private static final int MAX_PREVIEW_WIDTH = 1920;\r\n\r\n    /**\r\n     * Max preview height that is guaranteed by Camera2 API\r\n     */\r\n    private static final int MAX_PREVIEW_HEIGHT = 1080;\r\n\r\n    /**\r\n     * {@link TextureView.SurfaceTextureListener} handles several lifecycle events on a\r\n     * {@link TextureView}.\r\n     */\r\n    private final TextureView.SurfaceTextureListener mSurfaceTextureListener\r\n            = new TextureView.SurfaceTextureListener() {\r\n\r\n        @Override\r\n        public void onSurfaceTextureAvailable(SurfaceTexture texture, int width, int height) {\r\n            openCamera(width, height);\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureSizeChanged(SurfaceTexture texture, int width, int height) {\r\n            configureTransform(width, height);\r\n        }\r\n\r\n        @Override\r\n        public boolean onSurfaceTextureDestroyed(SurfaceTexture texture) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureUpdated(SurfaceTexture texture) {\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * ID of the current {@link CameraDevice}.\r\n     */\r\n    private String mCameraId;\r\n\r\n    /**\r\n     * An {@link AutoFitTextureView} for camera preview.\r\n     */\r\n    private AutoFitTextureView mTextureView;\r\n\r\n    /**\r\n     * A {@link CameraCaptureSession } for camera preview.\r\n     */\r\n    private CameraCaptureSession mCaptureSession;\r\n\r\n    /**\r\n     * A reference to the opened {@link CameraDevice}.\r\n     */\r\n    private CameraDevice mCameraDevice;\r\n\r\n    /**\r\n     * The {@link Size} of camera preview.\r\n     */\r\n    private Size mPreviewSize;\r\n\r\n    /**\r\n     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.\r\n     */\r\n    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {\r\n\r\n        @Override\r\n        public void onOpened(@NonNull CameraDevice cameraDevice) {\r\n            // This method is called when the camera is opened.  We start camera preview here.\r\n            mCameraOpenCloseLock.release();\r\n            mCameraDevice = cameraDevice;\r\n            createCameraPreviewSession();\r\n        }\r\n\r\n        @Override\r\n        public void onDisconnected(@NonNull CameraDevice cameraDevice) {\r\n            mCameraOpenCloseLock.release();\r\n            cameraDevice.close();\r\n            mCameraDevice = null;\r\n        }\r\n\r\n        @Override\r\n        public void onError(@NonNull CameraDevice cameraDevice, int error) {\r\n            mCameraOpenCloseLock.release();\r\n            cameraDevice.close();\r\n            mCameraDevice = null;\r\n            Activity activity = getActivity();\r\n            if (null != activity) {\r\n                activity.finish();\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * An additional thread for running tasks that shouldn't block the UI.\r\n     */\r\n    private HandlerThread mBackgroundThread;\r\n\r\n    /**\r\n     * A {@link Handler} for running tasks in the background.\r\n     */\r\n    private Handler mBackgroundHandler;\r\n\r\n    /**\r\n     * An {@link ImageReader} that handles still image capture.\r\n     */\r\n    private ImageReader mImageReader;\r\n\r\n    /**\r\n     * This is the output file for our picture.\r\n     */\r\n    private File mFile;\r\n\r\n    /**\r\n     * This a callback object for the {@link ImageReader}. \"onImageAvailable\" will be called when a\r\n     * still image is ready to be saved.\r\n     */\r\n    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener\r\n            = new ImageReader.OnImageAvailableListener() {\r\n\r\n        @Override\r\n        public void onImageAvailable(ImageReader reader) {\r\n            mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile));\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * {@link CaptureRequest.Builder} for the camera preview\r\n     */\r\n    private CaptureRequest.Builder mPreviewRequestBuilder;\r\n\r\n    /**\r\n     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}\r\n     */\r\n    private CaptureRequest mPreviewRequest;\r\n\r\n    /**\r\n     * The current state of camera state for taking pictures.\r\n     *\r\n     * @see #mCaptureCallback\r\n     */\r\n    private int mState = STATE_PREVIEW;\r\n\r\n    /**\r\n     * A {@link Semaphore} to prevent the app from exiting before closing the camera.\r\n     */\r\n    private Semaphore mCameraOpenCloseLock = new Semaphore(1);\r\n\r\n    /**\r\n     * Whether the current camera device supports Flash or not.\r\n     */\r\n    private boolean mFlashSupported;\r\n\r\n    /**\r\n     * Orientation of the camera sensor\r\n     */\r\n    private int mSensorOrientation;\r\n\r\n    /**\r\n     * A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.\r\n     */\r\n    private CameraCaptureSession.CaptureCallback mCaptureCallback\r\n            = new CameraCaptureSession.CaptureCallback() {\r\n\r\n        private void process(CaptureResult result) {\r\n            switch (mState) {\r\n                case STATE_PREVIEW: {\r\n                    // We have nothing to do when the camera preview is working normally.\r\n                    break;\r\n                }\r\n                case STATE_WAITING_LOCK: {\r\n                    Integer afState = result.get(CaptureResult.CONTROL_AF_STATE);\r\n                    if (afState == null) {\r\n                        captureStillPicture();\r\n                    } else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState ||\r\n                            CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) {\r\n                        // CONTROL_AE_STATE can be null on some devices\r\n                        Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                        if (aeState == null ||\r\n                                aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {\r\n                            mState = STATE_PICTURE_TAKEN;\r\n                            captureStillPicture();\r\n                        } else {\r\n                            runPrecaptureSequence();\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case STATE_WAITING_PRECAPTURE: {\r\n                    // CONTROL_AE_STATE can be null on some devices\r\n                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                    if (aeState == null ||\r\n                            aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||\r\n                            aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {\r\n                        mState = STATE_WAITING_NON_PRECAPTURE;\r\n                    }\r\n                    break;\r\n                }\r\n                case STATE_WAITING_NON_PRECAPTURE: {\r\n                    // CONTROL_AE_STATE can be null on some devices\r\n                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {\r\n                        mState = STATE_PICTURE_TAKEN;\r\n                        captureStillPicture();\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onCaptureProgressed(@NonNull CameraCaptureSession session,\r\n                                        @NonNull CaptureRequest request,\r\n                                        @NonNull CaptureResult partialResult) {\r\n            process(partialResult);\r\n        }\r\n\r\n        @Override\r\n        public void onCaptureCompleted(@NonNull CameraCaptureSession session,\r\n                                       @NonNull CaptureRequest request,\r\n                                       @NonNull TotalCaptureResult result) {\r\n            process(result);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Shows a {@link Toast} on the UI thread.\r\n     *\r\n     * @param text The message to show\r\n     */\r\n    private void showToast(final String text) {\r\n        final Activity activity = getActivity();\r\n        if (activity != null) {\r\n            activity.runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    Toast.makeText(activity, text, Toast.LENGTH_SHORT).show();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given {@code choices} of {@code Size}s supported by a camera, choose the smallest one that\r\n     * is at least as large as the respective texture view size, and that is at most as large as the\r\n     * respective max size, and whose aspect ratio matches with the specified value. If such size\r\n     * doesn't exist, choose the largest one that is at most as large as the respective max size,\r\n     * and whose aspect ratio matches with the specified value.\r\n     *\r\n     * @param choices           The list of sizes that the camera supports for the intended output\r\n     *                          class\r\n     * @param textureViewWidth  The width of the texture view relative to sensor coordinate\r\n     * @param textureViewHeight The height of the texture view relative to sensor coordinate\r\n     * @param maxWidth          The maximum width that can be chosen\r\n     * @param maxHeight         The maximum height that can be chosen\r\n     * @param aspectRatio       The aspect ratio\r\n     * @return The optimal {@code Size}, or an arbitrary one if none were big enough\r\n     */\r\n    private static Size chooseOptimalSize(Size[] choices, int textureViewWidth,\r\n                                          int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio) {\r\n\r\n        // Collect the supported resolutions that are at least as big as the preview Surface\r\n        List<Size> bigEnough = new ArrayList<>();\r\n        // Collect the supported resolutions that are smaller than the preview Surface\r\n        List<Size> notBigEnough = new ArrayList<>();\r\n        int w = aspectRatio.getWidth();\r\n        int h = aspectRatio.getHeight();\r\n        for (Size option : choices) {\r\n            if (option.getWidth() <= maxWidth && option.getHeight() <= maxHeight &&\r\n                    option.getHeight() == option.getWidth() * h / w) {\r\n                if (option.getWidth() >= textureViewWidth &&\r\n                        option.getHeight() >= textureViewHeight) {\r\n                    bigEnough.add(option);\r\n                } else {\r\n                    notBigEnough.add(option);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Pick the smallest of those big enough. If there is no one big enough, pick the\r\n        // largest of those not big enough.\r\n        if (bigEnough.size() > 0) {\r\n            return Collections.min(bigEnough, new CompareSizesByArea());\r\n        } else if (notBigEnough.size() > 0) {\r\n            return Collections.max(notBigEnough, new CompareSizesByArea());\r\n        } else {\r\n            Log.e(TAG, \"Couldn't find any suitable preview size\");\r\n            return choices[0];\r\n        }\r\n    }\r\n\r\n    public static CameraBackFragment newInstance() {\r\n        return new CameraBackFragment();\r\n    }\r\n\r\n    @Override\r\n    public void onCreate(@Nullable Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        frontImg = getActivity().getIntent().getStringExtra(\"uri\");\r\n        Log.d(TAG, \"frontImg: \"+frontImg);\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n        View  view =inflater.inflate(R.layout.fragment_camera_back, container, false);\r\n\r\n\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onViewCreated(final View view, Bundle savedInstanceState) {\r\n        view.findViewById(R.id.picture).setOnClickListener(this);\r\n        view.findViewById(R.id.info).setOnClickListener(this);\r\n        mTextureView = (AutoFitTextureView) view.findViewById(R.id.texture);\r\n        surfaceView = (SurfaceView) view.findViewById(R.id.surfaceView);\r\n        //imageView= view.findViewById(R.id.images);\r\n\r\n        surfaceView.setZOrderOnTop(true);\r\n        SurfaceHolder mHolder = surfaceView.getHolder();\r\n        mHolder.setFormat(PixelFormat.TRANSPARENT);\r\n        mHolder.addCallback(new SurfaceHolder.Callback() {\r\n            @Override\r\n            public void surfaceCreated(SurfaceHolder holder) {\r\n                Canvas canvas = holder.lockCanvas();\r\n                if (canvas == null) {\r\n                    Log.e(TAG, \"Cannot draw onto the canvas as it's null\");\r\n                } else {\r\n                    /*Paint myPaint = new Paint();\r\n                    myPaint.setColor(Color.rgb(100, 20, 50));\r\n\r\n                    myPaint.setStrokeWidth(10);\r\n                    myPaint.setStyle(Paint.Style.STROKE);\r\n                    canvas.drawRect(100, 100, 200, 200, myPaint);*/\r\n\r\n\r\n                    Display display =  getActivity().getWindowManager().getDefaultDisplay() ;\r\n                    Point size = new Point();\r\n                    display.getRealSize(size); // or getSize(size)\r\n                    width = size.x;\r\n                    height = size.y;\r\n\r\n\r\n                    Paint paint = new Paint();\r\n                    paint.setColor(Color.rgb(100, 20, 50));\r\n                    canvas.drawRect(width/2-112,height/2-112,width/2+112,height/2+112,paint);\r\n\r\n                    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));\r\n                    paint.setColor(Color.argb(100,0,0,0));\r\n                    canvas.drawRect(0,0,width,height,paint);\r\n\r\n                    // paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\r\n\r\n                    //paint.setARGB(50,0,0,0);\r\n                    //canvas.drawRect(100,100,200,200,paint);\r\n\r\n                    //canvas.drawRect(0,0,500,500,paint);\r\n\r\n\r\n\r\n                    holder.unlockCanvasAndPost(canvas);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void surfaceDestroyed(SurfaceHolder holder) {\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void onActivityCreated(Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        mFile = new File(getActivity().getExternalFilesDir(null), \"picB.jpg\");\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        super.onResume();\r\n        startBackgroundThread();\r\n\r\n        // When the screen is turned off and turned back on, the SurfaceTexture is already\r\n        // available, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\r\n        // a camera and start preview from here (otherwise, we wait until the surface is ready in\r\n        // the SurfaceTextureListener).\r\n        if (mTextureView.isAvailable()) {\r\n            openCamera(mTextureView.getWidth(), mTextureView.getHeight());\r\n        } else {\r\n            mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n        closeCamera();\r\n        stopBackgroundThread();\r\n        super.onPause();\r\n    }\r\n\r\n    private void requestCameraPermission() {\r\n        if (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {\r\n            new ConfirmationDialog().show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n        } else {\r\n            requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\r\n                                           @NonNull int[] grantResults) {\r\n        if (requestCode == REQUEST_CAMERA_PERMISSION) {\r\n            if (grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED) {\r\n                ErrorDialog.newInstance(getString(R.string.request_permission))\r\n                        .show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n            }\r\n        } else {\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up member variables related to camera.\r\n     *\r\n     * @param width  The width of available size for camera preview\r\n     * @param height The height of available size for camera preview\r\n     */\r\n    @SuppressWarnings(\"SuspiciousNameCombination\")\r\n    private void setUpCameraOutputs(int width, int height) {\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            for (String cameraId : manager.getCameraIdList()) {\r\n                CameraCharacteristics characteristics\r\n                        = manager.getCameraCharacteristics(cameraId);\r\n\r\n                // We don't use a front facing camera in this sample.\r\n                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);\r\n                if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {\r\n                    continue;\r\n                }\r\n\r\n                StreamConfigurationMap map = characteristics.get(\r\n                        CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\r\n                if (map == null) {\r\n                    continue;\r\n                }\r\n\r\n                // For still image captures, we use the largest available size.\r\n                Size largest = Collections.max(\r\n                        Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)),\r\n                        new CompareSizesByArea());\r\n\r\n                mImageReader = ImageReader.newInstance(width, height,\r\n                        ImageFormat.JPEG, /*maxImages*/2);\r\n                mImageReader.setOnImageAvailableListener(\r\n                        mOnImageAvailableListener, mBackgroundHandler);\r\n\r\n                // Find out if we need to swap dimension to get the preview size relative to sensor\r\n                // coordinate.\r\n                int displayRotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n                //noinspection ConstantConditions\r\n                mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\r\n                boolean swappedDimensions = false;\r\n                switch (displayRotation) {\r\n                    case Surface.ROTATION_0:\r\n                    case Surface.ROTATION_180:\r\n                        if (mSensorOrientation == 90 || mSensorOrientation == 270) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    case Surface.ROTATION_90:\r\n                    case Surface.ROTATION_270:\r\n                        if (mSensorOrientation == 0 || mSensorOrientation == 180) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        Log.e(TAG, \"Display rotation is invalid: \" + displayRotation);\r\n                }\r\n\r\n                Point displaySize = new Point();\r\n                activity.getWindowManager().getDefaultDisplay().getSize(displaySize);\r\n                int rotatedPreviewWidth = width;\r\n                int rotatedPreviewHeight = height;\r\n                int maxPreviewWidth = displaySize.x;\r\n                int maxPreviewHeight = displaySize.y;\r\n\r\n                if (swappedDimensions) {\r\n                    rotatedPreviewWidth = height;\r\n                    rotatedPreviewHeight = width;\r\n                    maxPreviewWidth = displaySize.y;\r\n                    maxPreviewHeight = displaySize.x;\r\n                }\r\n\r\n                if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {\r\n                    maxPreviewWidth = MAX_PREVIEW_WIDTH;\r\n                }\r\n\r\n                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {\r\n                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;\r\n                }\r\n\r\n\r\n\r\n                mPreviewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),\r\n                        rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,\r\n                        maxPreviewHeight, largest);\r\n\r\n\r\n                // We fit the aspect ratio of TextureView to the size of preview we picked.\r\n                int orientation = getResources().getConfiguration().orientation;\r\n                if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                    mTextureView.setAspectRatio(\r\n                            mPreviewSize.getWidth(), mPreviewSize.getHeight());\r\n                } else {\r\n                    mTextureView.setAspectRatio(\r\n                            mPreviewSize.getHeight(), mPreviewSize.getWidth());\r\n                }\r\n\r\n                // Check if the flash is supported.\r\n                Boolean available = characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);\r\n                mFlashSupported = available == null ? false : available;\r\n\r\n                mCameraId = cameraId;\r\n                return;\r\n            }\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (NullPointerException e) {\r\n            // Currently an NPE is thrown when the Camera2API is used but not supported on the\r\n            // device this code runs.\r\n            ErrorDialog.newInstance(getString(R.string.camera_error))\r\n                    .show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Opens the camera specified by {@link CameraBackFragment#mCameraId}.\r\n     */\r\n    private void openCamera(int width, int height) {\r\n        if (ContextCompat.checkSelfPermission(Objects.requireNonNull(getActivity()), Manifest.permission.CAMERA)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n            requestCameraPermission();\r\n            return;\r\n        }\r\n        setUpCameraOutputs(width, height);\r\n        configureTransform(width, height);\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {\r\n                throw new RuntimeException(\"Time out waiting to lock camera opening.\");\r\n            }\r\n            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera opening.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Closes the current {@link CameraDevice}.\r\n     */\r\n    private void closeCamera() {\r\n        try {\r\n            mCameraOpenCloseLock.acquire();\r\n            if (null != mCaptureSession) {\r\n                mCaptureSession.close();\r\n                mCaptureSession = null;\r\n            }\r\n            if (null != mCameraDevice) {\r\n                mCameraDevice.close();\r\n                mCameraDevice = null;\r\n            }\r\n            if (null != mImageReader) {\r\n                mImageReader.close();\r\n                mImageReader = null;\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera closing.\", e);\r\n        } finally {\r\n            mCameraOpenCloseLock.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a background thread and its {@link Handler}.\r\n     */\r\n    private void startBackgroundThread() {\r\n        mBackgroundThread = new HandlerThread(\"CameraBackground\");\r\n        mBackgroundThread.start();\r\n        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());\r\n    }\r\n\r\n    /**\r\n     * Stops the background thread and its {@link Handler}.\r\n     */\r\n    private void stopBackgroundThread() {\r\n        mBackgroundThread.quitSafely();\r\n        try {\r\n            mBackgroundThread.join();\r\n            mBackgroundThread = null;\r\n            mBackgroundHandler = null;\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new {@link CameraCaptureSession} for camera preview.\r\n     */\r\n    private void createCameraPreviewSession() {\r\n        try {\r\n            SurfaceTexture texture = mTextureView.getSurfaceTexture();\r\n            assert texture != null;\r\n\r\n            // We configure the size of default buffer to be the size of camera preview we want.\r\n            texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());\r\n\r\n            // This is the output Surface we need to start preview.\r\n            Surface surface = new Surface(texture);\r\n\r\n            // We set up a CaptureRequest.Builder with the output Surface.\r\n            mPreviewRequestBuilder\r\n                    = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\r\n            mPreviewRequestBuilder.addTarget(surface);\r\n\r\n            // Here, we create a CameraCaptureSession for camera preview.\r\n            mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),\r\n                    new CameraCaptureSession.StateCallback() {\r\n\r\n                        @Override\r\n                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            // The camera is already closed\r\n                            if (null == mCameraDevice) {\r\n                                return;\r\n                            }\r\n\r\n                            // When the session is ready, we start displaying the preview.\r\n                            mCaptureSession = cameraCaptureSession;\r\n                            try {\r\n                                // Auto focus should be continuous for camera preview.\r\n                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,\r\n                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n                                // Flash is automatically enabled when necessary.\r\n                                setAutoFlash(mPreviewRequestBuilder);\r\n\r\n                                // Finally, we start displaying the camera preview.\r\n                                mPreviewRequest = mPreviewRequestBuilder.build();\r\n                                mCaptureSession.setRepeatingRequest(mPreviewRequest,\r\n                                        mCaptureCallback, mBackgroundHandler);\r\n                            } catch (CameraAccessException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        }\r\n\r\n                        @Override\r\n                        public void onConfigureFailed(\r\n                                @NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            showToast(\"Failed\");\r\n                        }\r\n                    }, null\r\n            );\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the necessary {@link Matrix} transformation to `mTextureView`.\r\n     * This method should be called after the camera preview size is determined in\r\n     * setUpCameraOutputs and also the size of `mTextureView` is fixed.\r\n     *\r\n     * @param viewWidth  The width of `mTextureView`\r\n     * @param viewHeight The height of `mTextureView`\r\n     */\r\n    private void configureTransform(int viewWidth, int viewHeight) {\r\n        Activity activity = getActivity();\r\n        if (null == mTextureView || null == mPreviewSize || null == activity) {\r\n            return;\r\n        }\r\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n        Matrix matrix = new Matrix();\r\n        RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);\r\n        RectF bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());\r\n        float centerX = viewRect.centerX();\r\n        float centerY = viewRect.centerY();\r\n        if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {\r\n            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());\r\n            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\r\n            float scale = Math.max(\r\n                    (float) viewHeight / mPreviewSize.getHeight(),\r\n                    (float) viewWidth / mPreviewSize.getWidth());\r\n            matrix.postScale(scale, scale, centerX, centerY);\r\n            matrix.postRotate(90 * (rotation - 2), centerX, centerY);\r\n        } else if (Surface.ROTATION_180 == rotation) {\r\n            matrix.postRotate(180, centerX, centerY);\r\n        }\r\n        mTextureView.setTransform(matrix);\r\n    }\r\n\r\n    /**\r\n     * Initiate a still image capture.\r\n     */\r\n    private void takePicture() {\r\n        lockFocus();\r\n    }\r\n\r\n    /**\r\n     * Lock the focus as the first step for a still image capture.\r\n     */\r\n    private void lockFocus() {\r\n        try {\r\n            // This is how to tell the camera to lock focus.\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,\r\n                    CameraMetadata.CONTROL_AF_TRIGGER_START);\r\n            // Tell #mCaptureCallback to wait for the lock.\r\n            mState = STATE_WAITING_LOCK;\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run the precapture sequence for capturing a still image. This method should be called when\r\n     * we get a response in {@link #mCaptureCallback} from {@link #lockFocus()}.\r\n     */\r\n    private void runPrecaptureSequence() {\r\n        try {\r\n            // This is how to tell the camera to trigger.\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,\r\n                    CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);\r\n            // Tell #mCaptureCallback to wait for the precapture sequence to be set.\r\n            mState = STATE_WAITING_PRECAPTURE;\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Capture a still picture. This method should be called when we get a response in\r\n     * {@link #mCaptureCallback} from both {@link #lockFocus()}.\r\n     */\r\n    private void captureStillPicture() {\r\n        try {\r\n            final Activity activity = getActivity();\r\n            if (null == activity || null == mCameraDevice) {\r\n                return;\r\n            }\r\n            // This is the CaptureRequest.Builder that we use to take a picture.\r\n            final CaptureRequest.Builder captureBuilder =\r\n                    mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);\r\n            captureBuilder.addTarget(mImageReader.getSurface());\r\n\r\n            // Use the same AE and AF modes as the preview.\r\n            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,\r\n                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n            setAutoFlash(captureBuilder);\r\n\r\n            // Orientation\r\n            int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));\r\n\r\n            CameraCaptureSession.CaptureCallback CaptureCallback\r\n                    = new CameraCaptureSession.CaptureCallback() {\r\n\r\n                @Override\r\n                public void onCaptureCompleted(@NonNull CameraCaptureSession session,\r\n                                               @NonNull CaptureRequest request,\r\n                                               @NonNull TotalCaptureResult result) {\r\n                    showToast(\"Saved: \" + mFile);\r\n\r\n\r\n                    //Intent intent = new Intent(getActivity(),MainActivity.class);\r\n                    //Intent intent = new Intent(getActivity(), OcrSpaceActivity.class);\r\n                    Intent intent = new Intent(getActivity(), KakaoOCRActivity.class);\r\n                    intent.putExtra(\"frontImg\",frontImg);\r\n                    intent.putExtra(\"backImg\",mFile.getAbsolutePath());\r\n\r\n                    startActivity(intent);\r\n                    //   imageView.setImageResource(R.drawable.tile);\r\n                    //  imageView.setImageURI(Uri.parse(mFile.getAbsolutePath()));\r\n                    unlockFocus();\r\n                }\r\n            };\r\n\r\n            mCaptureSession.stopRepeating();\r\n            mCaptureSession.abortCaptures();\r\n            mCaptureSession.capture(captureBuilder.build(), CaptureCallback, null);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the JPEG orientation from the specified screen rotation.\r\n     *\r\n     * @param rotation The screen rotation.\r\n     * @return The JPEG orientation (one of 0, 90, 270, and 360)\r\n     */\r\n    private int getOrientation(int rotation) {\r\n        // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)\r\n        // We have to take that into account and rotate JPEG properly.\r\n        // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.\r\n        // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.\r\n        return (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360;\r\n    }\r\n\r\n    /**\r\n     * Unlock the focus. This method should be called when still image capture sequence is\r\n     * finished.\r\n     */\r\n    private void unlockFocus() {\r\n        try {\r\n            // Reset the auto-focus trigger\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,\r\n                    CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);\r\n            setAutoFlash(mPreviewRequestBuilder);\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n            // After this, the camera will go back to the normal state of preview.\r\n            mState = STATE_PREVIEW;\r\n            mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback,\r\n                    mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onClick(View view) {\r\n        switch (view.getId()) {\r\n            case R.id.picture: {\r\n                takePicture();\r\n                break;\r\n            }\r\n            case R.id.info: {\r\n                Activity activity = getActivity();\r\n                if (null != activity) {\r\n                    new AlertDialog.Builder(activity)\r\n                            .setMessage(R.string.intro_message)\r\n                            .setPositiveButton(android.R.string.ok, null)\r\n                            .show();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void setAutoFlash(CaptureRequest.Builder requestBuilder) {\r\n        if (mFlashSupported) {\r\n            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,\r\n                    CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves a JPEG {@link Image} into the specified {@link File}.\r\n     */\r\n    private static class ImageSaver implements Runnable {\r\n\r\n        /**\r\n         * The JPEG image\r\n         */\r\n        private final Image mImage;\r\n        /**\r\n         * The file we save the image into.\r\n         */\r\n        private final File mFile;\r\n\r\n        ImageSaver(Image image, File file) {\r\n            mImage = image;\r\n            mFile = file;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            ByteBuffer buffer = mImage.getPlanes()[0].getBuffer();\r\n            byte[] bytes = new byte[buffer.remaining()];\r\n            buffer.get(bytes);\r\n            FileOutputStream output = null;\r\n            try {\r\n                output = new FileOutputStream(mFile);\r\n                output.write(bytes);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                mImage.close();\r\n                if (null != output) {\r\n                    try {\r\n                        output.close();\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Compares two {@code Size}s based on their areas.\r\n     */\r\n    static class CompareSizesByArea implements Comparator<Size> {\r\n\r\n        @Override\r\n        public int compare(Size lhs, Size rhs) {\r\n            // We cast here to ensure the multiplications won't overflow\r\n            return Long.signum((long) lhs.getWidth() * lhs.getHeight() -\r\n                    (long) rhs.getWidth() * rhs.getHeight());\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Shows an error message dialog.\r\n     */\r\n    public static class ErrorDialog extends DialogFragment {\r\n\r\n        private static final String ARG_MESSAGE = \"message\";\r\n\r\n        public static ErrorDialog newInstance(String message) {\r\n            ErrorDialog dialog = new ErrorDialog();\r\n            Bundle args = new Bundle();\r\n            args.putString(ARG_MESSAGE, message);\r\n            dialog.setArguments(args);\r\n            return dialog;\r\n        }\r\n\r\n        @NonNull\r\n        @Override\r\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\r\n            final Activity activity = getActivity();\r\n            return new AlertDialog.Builder(activity)\r\n                    .setMessage(getArguments().getString(ARG_MESSAGE))\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialogInterface, int i) {\r\n                            activity.finish();\r\n                        }\r\n                    })\r\n                    .create();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Shows OK/Cancel confirmation dialog about camera permission.\r\n     */\r\n    public static class ConfirmationDialog extends DialogFragment {\r\n\r\n        @NonNull\r\n        @Override\r\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\r\n            final Fragment parent = getParentFragment();\r\n            return new AlertDialog.Builder(getActivity())\r\n                    .setMessage(R.string.request_permission)\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            parent.requestPermissions(new String[]{Manifest.permission.CAMERA},\r\n                                    REQUEST_CAMERA_PERMISSION);\r\n                        }\r\n                    })\r\n                    .setNegativeButton(android.R.string.cancel,\r\n                            new DialogInterface.OnClickListener() {\r\n                                @Override\r\n                                public void onClick(DialogInterface dialog, int which) {\r\n                                    Activity activity = parent.getActivity();\r\n                                    if (activity != null) {\r\n                                        activity.finish();\r\n                                    }\r\n                                }\r\n                            })\r\n                    .create();\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackFragment.java	(revision 9884ed4171d8562cb45e945e27cc9b6fbb2a1385)
+++ app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackFragment.java	(date 1607325129040)
@@ -92,6 +92,7 @@
 public class CameraBackFragment extends Fragment
         implements View.OnClickListener, ActivityCompat.OnRequestPermissionsResultCallback {
 
+
     /**
      * Conversion from screen rotation to JPEG orientation.
      */
@@ -101,6 +102,7 @@
     int width ;
     int height;
     String frontImg;
+
     private static final SparseIntArray ORIENTATIONS = new SparseIntArray();
     private static final int REQUEST_CAMERA_PERMISSION = 1;
     private static final String FRAGMENT_DIALOG = "dialog";
@@ -110,7 +112,10 @@
         ORIENTATIONS.append(Surface.ROTATION_90, 0);
         ORIENTATIONS.append(Surface.ROTATION_180, 270);
         ORIENTATIONS.append(Surface.ROTATION_270, 180);
+
     }
+
+
 
     /**
      * Tag for the {@link Log}.
@@ -1136,5 +1141,8 @@
                     .create();
         }
     }
+    public Fragment removeFrament() {
+        return this;
+    }
 
 }
\ No newline at end of file
Index: app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright 2017 The Android Open Source Project\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *       http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage com.example.smrpv2.ui.medicine.medshot;\r\n\r\n\r\nimport android.Manifest;\r\nimport android.app.Activity;\r\nimport android.app.AlertDialog;\r\nimport android.app.Dialog;\r\nimport android.content.Context;\r\nimport android.content.DialogInterface;\r\nimport android.content.Intent;\r\nimport android.content.pm.PackageManager;\r\nimport android.content.res.Configuration;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.ImageFormat;\r\nimport android.graphics.Matrix;\r\nimport android.graphics.Paint;\r\nimport android.graphics.PixelFormat;\r\nimport android.graphics.Point;\r\nimport android.graphics.PorterDuff;\r\nimport android.graphics.PorterDuffXfermode;\r\nimport android.graphics.RectF;\r\nimport android.graphics.SurfaceTexture;\r\nimport android.graphics.Xfermode;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.hardware.camera2.CameraAccessException;\r\nimport android.hardware.camera2.CameraCaptureSession;\r\nimport android.hardware.camera2.CameraCharacteristics;\r\nimport android.hardware.camera2.CameraDevice;\r\nimport android.hardware.camera2.CameraManager;\r\nimport android.hardware.camera2.CameraMetadata;\r\nimport android.hardware.camera2.CaptureRequest;\r\nimport android.hardware.camera2.CaptureResult;\r\nimport android.hardware.camera2.TotalCaptureResult;\r\nimport android.hardware.camera2.params.StreamConfigurationMap;\r\nimport android.media.Image;\r\nimport android.media.ImageReader;\r\nimport android.net.Uri;\r\nimport android.os.Bundle;\r\nimport android.os.Handler;\r\nimport android.os.HandlerThread;\r\nimport android.util.DisplayMetrics;\r\nimport android.util.Log;\r\nimport android.util.Size;\r\nimport android.util.SparseIntArray;\r\nimport android.view.Display;\r\nimport android.view.LayoutInflater;\r\nimport android.view.Surface;\r\nimport android.view.SurfaceHolder;\r\nimport android.view.SurfaceView;\r\nimport android.view.TextureView;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.app.ActivityCompat;\r\nimport androidx.core.content.ContextCompat;\r\nimport androidx.fragment.app.DialogFragment;\r\nimport androidx.fragment.app.Fragment;\r\n\r\nimport com.example.smrpv2.R;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.ByteBuffer;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Collections;\r\nimport java.util.Comparator;\r\nimport java.util.List;\r\nimport java.util.Objects;\r\nimport java.util.concurrent.Semaphore;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class CameraFrontFragment extends Fragment\r\n        implements View.OnClickListener, ActivityCompat.OnRequestPermissionsResultCallback {\r\n\r\n    /**\r\n     * Conversion from screen rotation to JPEG orientation.\r\n     */\r\n    ImageView imageView;\r\n    LinearLayout linearlayout;\r\n    SurfaceView surfaceView;\r\n    int width ;\r\n    int height;\r\n    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();\r\n    private static final int REQUEST_CAMERA_PERMISSION = 1;\r\n    private static final String FRAGMENT_DIALOG = \"dialog\";\r\n\r\n    static {\r\n        ORIENTATIONS.append(Surface.ROTATION_0, 90);\r\n        ORIENTATIONS.append(Surface.ROTATION_90, 0);\r\n        ORIENTATIONS.append(Surface.ROTATION_180, 270);\r\n        ORIENTATIONS.append(Surface.ROTATION_270, 180);\r\n    }\r\n\r\n    /**\r\n     * Tag for the {@link Log}.\r\n     */\r\n    private static final String TAG = \"CameraFrontFragment\";\r\n\r\n    /**\r\n     * Camera state: Showing camera preview.\r\n     */\r\n    private static final int STATE_PREVIEW = 0;\r\n\r\n    /**\r\n     * Camera state: Waiting for the focus to be locked.\r\n     */\r\n    private static final int STATE_WAITING_LOCK = 1;\r\n\r\n    /**\r\n     * Camera state: Waiting for the exposure to be precapture state.\r\n     */\r\n    private static final int STATE_WAITING_PRECAPTURE = 2;\r\n\r\n    /**\r\n     * Camera state: Waiting for the exposure state to be something other than precapture.\r\n     */\r\n    private static final int STATE_WAITING_NON_PRECAPTURE = 3;\r\n\r\n    /**\r\n     * Camera state: Picture was taken.\r\n     */\r\n    private static final int STATE_PICTURE_TAKEN = 4;\r\n\r\n    /**\r\n     * Max preview width that is guaranteed by Camera2 API\r\n     */\r\n    private static final int MAX_PREVIEW_WIDTH = 1920;\r\n\r\n    /**\r\n     * Max preview height that is guaranteed by Camera2 API\r\n     */\r\n    private static final int MAX_PREVIEW_HEIGHT = 1080;\r\n\r\n    /**\r\n     * {@link TextureView.SurfaceTextureListener} handles several lifecycle events on a\r\n     * {@link TextureView}.\r\n     */\r\n    private final TextureView.SurfaceTextureListener mSurfaceTextureListener\r\n            = new TextureView.SurfaceTextureListener() {\r\n\r\n        @Override\r\n        public void onSurfaceTextureAvailable(SurfaceTexture texture, int width, int height) {\r\n            openCamera(width, height);\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureSizeChanged(SurfaceTexture texture, int width, int height) {\r\n            configureTransform(width, height);\r\n        }\r\n\r\n        @Override\r\n        public boolean onSurfaceTextureDestroyed(SurfaceTexture texture) {\r\n            return true;\r\n        }\r\n\r\n        @Override\r\n        public void onSurfaceTextureUpdated(SurfaceTexture texture) {\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * ID of the current {@link CameraDevice}.\r\n     */\r\n    private String mCameraId;\r\n\r\n    /**\r\n     * An {@link AutoFitTextureView} for camera preview.\r\n     */\r\n    private AutoFitTextureView mTextureView;\r\n\r\n    /**\r\n     * A {@link CameraCaptureSession } for camera preview.\r\n     */\r\n    private CameraCaptureSession mCaptureSession;\r\n\r\n    /**\r\n     * A reference to the opened {@link CameraDevice}.\r\n     */\r\n    private CameraDevice mCameraDevice;\r\n\r\n    /**\r\n     * The {@link Size} of camera preview.\r\n     */\r\n    private Size mPreviewSize;\r\n\r\n    /**\r\n     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.\r\n     */\r\n    private final CameraDevice.StateCallback mStateCallback = new CameraDevice.StateCallback() {\r\n\r\n        @Override\r\n        public void onOpened(@NonNull CameraDevice cameraDevice) {\r\n            // This method is called when the camera is opened.  We start camera preview here.\r\n            mCameraOpenCloseLock.release();\r\n            mCameraDevice = cameraDevice;\r\n            createCameraPreviewSession();\r\n        }\r\n\r\n        @Override\r\n        public void onDisconnected(@NonNull CameraDevice cameraDevice) {\r\n            mCameraOpenCloseLock.release();\r\n            cameraDevice.close();\r\n            mCameraDevice = null;\r\n        }\r\n\r\n        @Override\r\n        public void onError(@NonNull CameraDevice cameraDevice, int error) {\r\n            mCameraOpenCloseLock.release();\r\n            cameraDevice.close();\r\n            mCameraDevice = null;\r\n            Activity activity = getActivity();\r\n            if (null != activity) {\r\n                activity.finish();\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * An additional thread for running tasks that shouldn't block the UI.\r\n     */\r\n    private HandlerThread mBackgroundThread;\r\n\r\n    /**\r\n     * A {@link Handler} for running tasks in the background.\r\n     */\r\n    private Handler mBackgroundHandler;\r\n\r\n    /**\r\n     * An {@link ImageReader} that handles still image capture.\r\n     */\r\n    private ImageReader mImageReader;\r\n\r\n    /**\r\n     * This is the output file for our picture.\r\n     */\r\n    private File mFile;\r\n\r\n    /**\r\n     * This a callback object for the {@link ImageReader}. \"onImageAvailable\" will be called when a\r\n     * still image is ready to be saved.\r\n     */\r\n    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener\r\n            = new ImageReader.OnImageAvailableListener() {\r\n\r\n        @Override\r\n        public void onImageAvailable(ImageReader reader) {\r\n            mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile));\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * {@link CaptureRequest.Builder} for the camera preview\r\n     */\r\n    private CaptureRequest.Builder mPreviewRequestBuilder;\r\n\r\n    /**\r\n     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}\r\n     */\r\n    private CaptureRequest mPreviewRequest;\r\n\r\n    /**\r\n     * The current state of camera state for taking pictures.\r\n     *\r\n     * @see #mCaptureCallback\r\n     */\r\n    private int mState = STATE_PREVIEW;\r\n\r\n    /**\r\n     * A {@link Semaphore} to prevent the app from exiting before closing the camera.\r\n     */\r\n    private Semaphore mCameraOpenCloseLock = new Semaphore(1);\r\n\r\n    /**\r\n     * Whether the current camera device supports Flash or not.\r\n     */\r\n    private boolean mFlashSupported;\r\n\r\n    /**\r\n     * Orientation of the camera sensor\r\n     */\r\n    private int mSensorOrientation;\r\n\r\n    /**\r\n     * A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.\r\n     */\r\n    private CameraCaptureSession.CaptureCallback mCaptureCallback\r\n            = new CameraCaptureSession.CaptureCallback() {\r\n\r\n        private void process(CaptureResult result) {\r\n            switch (mState) {\r\n                case STATE_PREVIEW: {\r\n                    // We have nothing to do when the camera preview is working normally.\r\n                    break;\r\n                }\r\n                case STATE_WAITING_LOCK: {\r\n                    Integer afState = result.get(CaptureResult.CONTROL_AF_STATE);\r\n                    if (afState == null) {\r\n                        captureStillPicture();\r\n                    } else if (CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED == afState ||\r\n                            CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED == afState) {\r\n                        // CONTROL_AE_STATE can be null on some devices\r\n                        Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                        if (aeState == null ||\r\n                                aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED) {\r\n                            mState = STATE_PICTURE_TAKEN;\r\n                            captureStillPicture();\r\n                        } else {\r\n                            runPrecaptureSequence();\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case STATE_WAITING_PRECAPTURE: {\r\n                    // CONTROL_AE_STATE can be null on some devices\r\n                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                    if (aeState == null ||\r\n                            aeState == CaptureResult.CONTROL_AE_STATE_PRECAPTURE ||\r\n                            aeState == CaptureRequest.CONTROL_AE_STATE_FLASH_REQUIRED) {\r\n                        mState = STATE_WAITING_NON_PRECAPTURE;\r\n                    }\r\n                    break;\r\n                }\r\n                case STATE_WAITING_NON_PRECAPTURE: {\r\n                    // CONTROL_AE_STATE can be null on some devices\r\n                    Integer aeState = result.get(CaptureResult.CONTROL_AE_STATE);\r\n                    if (aeState == null || aeState != CaptureResult.CONTROL_AE_STATE_PRECAPTURE) {\r\n                        mState = STATE_PICTURE_TAKEN;\r\n                        captureStillPicture();\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        @Override\r\n        public void onCaptureProgressed(@NonNull CameraCaptureSession session,\r\n                                        @NonNull CaptureRequest request,\r\n                                        @NonNull CaptureResult partialResult) {\r\n            process(partialResult);\r\n        }\r\n\r\n        @Override\r\n        public void onCaptureCompleted(@NonNull CameraCaptureSession session,\r\n                                       @NonNull CaptureRequest request,\r\n                                       @NonNull TotalCaptureResult result) {\r\n            process(result);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Shows a {@link Toast} on the UI thread.\r\n     *\r\n     * @param text The message to show\r\n     */\r\n    private void showToast(final String text) {\r\n        final Activity activity = getActivity();\r\n        if (activity != null) {\r\n            activity.runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    Toast.makeText(activity, text, Toast.LENGTH_SHORT).show();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given {@code choices} of {@code Size}s supported by a camera, choose the smallest one that\r\n     * is at least as large as the respective texture view size, and that is at most as large as the\r\n     * respective max size, and whose aspect ratio matches with the specified value. If such size\r\n     * doesn't exist, choose the largest one that is at most as large as the respective max size,\r\n     * and whose aspect ratio matches with the specified value.\r\n     *\r\n     * @param choices           The list of sizes that the camera supports for the intended output\r\n     *                          class\r\n     * @param textureViewWidth  The width of the texture view relative to sensor coordinate\r\n     * @param textureViewHeight The height of the texture view relative to sensor coordinate\r\n     * @param maxWidth          The maximum width that can be chosen\r\n     * @param maxHeight         The maximum height that can be chosen\r\n     * @param aspectRatio       The aspect ratio\r\n     * @return The optimal {@code Size}, or an arbitrary one if none were big enough\r\n     */\r\n    private static Size chooseOptimalSize(Size[] choices, int textureViewWidth,\r\n                                          int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio) {\r\n\r\n        // Collect the supported resolutions that are at least as big as the preview Surface\r\n        List<Size> bigEnough = new ArrayList<>();\r\n        // Collect the supported resolutions that are smaller than the preview Surface\r\n        List<Size> notBigEnough = new ArrayList<>();\r\n        int w = aspectRatio.getWidth();\r\n        int h = aspectRatio.getHeight();\r\n        for (Size option : choices) {\r\n            if (option.getWidth() <= maxWidth && option.getHeight() <= maxHeight &&\r\n                    option.getHeight() == option.getWidth() * h / w) {\r\n                if (option.getWidth() >= textureViewWidth &&\r\n                        option.getHeight() >= textureViewHeight) {\r\n                    bigEnough.add(option);\r\n                } else {\r\n                    notBigEnough.add(option);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Pick the smallest of those big enough. If there is no one big enough, pick the\r\n        // largest of those not big enough.\r\n        if (bigEnough.size() > 0) {\r\n            return Collections.min(bigEnough, new CompareSizesByArea());\r\n        } else if (notBigEnough.size() > 0) {\r\n            return Collections.max(notBigEnough, new CompareSizesByArea());\r\n        } else {\r\n            Log.e(TAG, \"Couldn't find any suitable preview size\");\r\n            return choices[0];\r\n        }\r\n    }\r\n\r\n    public static CameraFrontFragment newInstance() {\r\n        return new CameraFrontFragment();\r\n    }\r\n\r\n    @Override\r\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n        View  view =inflater.inflate(R.layout.fragment_camera_front, container, false);\r\n        return view;\r\n    }\r\n\r\n    @Override\r\n    public void onViewCreated(final View view, Bundle savedInstanceState) {\r\n        view.findViewById(R.id.picture).setOnClickListener(this);\r\n        view.findViewById(R.id.info).setOnClickListener(this);\r\n        mTextureView = (AutoFitTextureView) view.findViewById(R.id.texture);\r\n        surfaceView = (SurfaceView) view.findViewById(R.id.surfaceView);\r\n        //imageView= view.findViewById(R.id.images);\r\n\r\n        surfaceView.setZOrderOnTop(true);\r\n        SurfaceHolder mHolder = surfaceView.getHolder();\r\n        mHolder.setFormat(PixelFormat.TRANSPARENT);\r\n        mHolder.addCallback(new SurfaceHolder.Callback() {\r\n            @Override\r\n            public void surfaceCreated(SurfaceHolder holder) {\r\n                Canvas canvas = holder.lockCanvas();\r\n                if (canvas == null) {\r\n                    Log.e(TAG, \"Cannot draw onto the canvas as it's null\");\r\n                } else {\r\n                    /*Paint myPaint = new Paint();\r\n                    myPaint.setColor(Color.rgb(100, 20, 50));\r\n\r\n                    myPaint.setStrokeWidth(10);\r\n                    myPaint.setStyle(Paint.Style.STROKE);\r\n                    canvas.drawRect(100, 100, 200, 200, myPaint);*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n                    Display display =  getActivity().getWindowManager().getDefaultDisplay() ;\r\n                    Point size = new Point();\r\n                    display.getRealSize(size); // or getSize(size)\r\n                    width = size.x;\r\n                    height = size.y;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                    Paint paint = new Paint();\r\n                    paint.setColor(Color.rgb(100, 20, 50));\r\n                    canvas.drawRect(width/2-112,height/2-112,width/2+112,height/2+112,paint);\r\n\r\n                    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));\r\n                    paint.setColor(Color.argb(100,0,0,0));\r\n                    canvas.drawRect(0,0,width,height,paint);\r\n\r\n                    // paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST));\r\n\r\n                    //paint.setARGB(50,0,0,0);\r\n                    //canvas.drawRect(100,100,200,200,paint);\r\n\r\n                    //canvas.drawRect(0,0,500,500,paint);\r\n\r\n\r\n\r\n                    holder.unlockCanvasAndPost(canvas);\r\n                }\r\n            }\r\n\r\n            @Override\r\n            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\r\n\r\n            }\r\n\r\n            @Override\r\n            public void surfaceDestroyed(SurfaceHolder holder) {\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public void onActivityCreated(Bundle savedInstanceState) {\r\n        super.onActivityCreated(savedInstanceState);\r\n        mFile = new File(getActivity().getExternalFilesDir(null), \"picF.jpg\");\r\n    }\r\n\r\n    @Override\r\n    public void onResume() {\r\n        super.onResume();\r\n        startBackgroundThread();\r\n\r\n        // When the screen is turned off and turned back on, the SurfaceTexture is already\r\n        // available, and \"onSurfaceTextureAvailable\" will not be called. In that case, we can open\r\n        // a camera and start preview from here (otherwise, we wait until the surface is ready in\r\n        // the SurfaceTextureListener).\r\n        if (mTextureView.isAvailable()) {\r\n            openCamera(mTextureView.getWidth(), mTextureView.getHeight());\r\n        } else {\r\n            mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onPause() {\r\n        closeCamera();\r\n        stopBackgroundThread();\r\n        super.onPause();\r\n    }\r\n\r\n    private void requestCameraPermission() {\r\n        if (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) {\r\n            new ConfirmationDialog().show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n        } else {\r\n            requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\r\n                                           @NonNull int[] grantResults) {\r\n        if (requestCode == REQUEST_CAMERA_PERMISSION) {\r\n            if (grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED) {\r\n                ErrorDialog.newInstance(getString(R.string.request_permission))\r\n                        .show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n            }\r\n        } else {\r\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up member variables related to camera.\r\n     *\r\n     * @param width  The width of available size for camera preview\r\n     * @param height The height of available size for camera preview\r\n     */\r\n    @SuppressWarnings(\"SuspiciousNameCombination\")\r\n    private void setUpCameraOutputs(int width, int height) {\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            for (String cameraId : manager.getCameraIdList()) {\r\n                CameraCharacteristics characteristics\r\n                        = manager.getCameraCharacteristics(cameraId);\r\n\r\n                // We don't use a front facing camera in this sample.\r\n                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);\r\n                if (facing != null && facing == CameraCharacteristics.LENS_FACING_FRONT) {\r\n                    continue;\r\n                }\r\n\r\n                StreamConfigurationMap map = characteristics.get(\r\n                        CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);\r\n                if (map == null) {\r\n                    continue;\r\n                }\r\n\r\n                // For still image captures, we use the largest available size.\r\n                Size largest = Collections.max(\r\n                        Arrays.asList(map.getOutputSizes(ImageFormat.JPEG)),\r\n                        new CompareSizesByArea());\r\n\r\n                mImageReader = ImageReader.newInstance(width, height,\r\n                        ImageFormat.JPEG, /*maxImages*/2);\r\n                mImageReader.setOnImageAvailableListener(\r\n                        mOnImageAvailableListener, mBackgroundHandler);\r\n\r\n                // Find out if we need to swap dimension to get the preview size relative to sensor\r\n                // coordinate.\r\n                int displayRotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n                //noinspection ConstantConditions\r\n                mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);\r\n                boolean swappedDimensions = false;\r\n                switch (displayRotation) {\r\n                    case Surface.ROTATION_0:\r\n                    case Surface.ROTATION_180:\r\n                        if (mSensorOrientation == 90 || mSensorOrientation == 270) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    case Surface.ROTATION_90:\r\n                    case Surface.ROTATION_270:\r\n                        if (mSensorOrientation == 0 || mSensorOrientation == 180) {\r\n                            swappedDimensions = true;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        Log.e(TAG, \"Display rotation is invalid: \" + displayRotation);\r\n                }\r\n\r\n                Point displaySize = new Point();\r\n                activity.getWindowManager().getDefaultDisplay().getSize(displaySize);\r\n                int rotatedPreviewWidth = width;\r\n                int rotatedPreviewHeight = height;\r\n                int maxPreviewWidth = displaySize.x;\r\n                int maxPreviewHeight = displaySize.y;\r\n\r\n                if (swappedDimensions) {\r\n                    rotatedPreviewWidth = height;\r\n                    rotatedPreviewHeight = width;\r\n                    maxPreviewWidth = displaySize.y;\r\n                    maxPreviewHeight = displaySize.x;\r\n                }\r\n\r\n                if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {\r\n                    maxPreviewWidth = MAX_PREVIEW_WIDTH;\r\n                }\r\n\r\n                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {\r\n                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;\r\n                }\r\n\r\n\r\n\r\n                // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera\r\n                // bus' bandwidth limitation, resulting in gorgeous previews but the storage of\r\n                // garbage capture data.\r\n\r\n                mPreviewSize = chooseOptimalSize(map.getOutputSizes(SurfaceTexture.class),\r\n                        rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,\r\n                        maxPreviewHeight, largest);\r\n\r\n\r\n                // We fit the aspect ratio of TextureView to the size of preview we picked.\r\n                int orientation = getResources().getConfiguration().orientation;\r\n                if (orientation == Configuration.ORIENTATION_LANDSCAPE) {\r\n                    mTextureView.setAspectRatio(\r\n                            mPreviewSize.getWidth(), mPreviewSize.getHeight());\r\n                } else {\r\n                    mTextureView.setAspectRatio(\r\n                            mPreviewSize.getHeight(), mPreviewSize.getWidth());\r\n                }\r\n\r\n                // Check if the flash is supported.\r\n                Boolean available = characteristics.get(CameraCharacteristics.FLASH_INFO_AVAILABLE);\r\n                mFlashSupported = available == null ? false : available;\r\n\r\n                mCameraId = cameraId;\r\n                return;\r\n            }\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (NullPointerException e) {\r\n            // Currently an NPE is thrown when the Camera2API is used but not supported on the\r\n            // device this code runs.\r\n            ErrorDialog.newInstance(getString(R.string.camera_error))\r\n                    .show(getChildFragmentManager(), FRAGMENT_DIALOG);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Opens the camera specified by {@link CameraFrontFragment#mCameraId}.\r\n     */\r\n    private void openCamera(int width, int height) {\r\n        if (ContextCompat.checkSelfPermission(Objects.requireNonNull(getActivity()), Manifest.permission.CAMERA)\r\n                != PackageManager.PERMISSION_GRANTED) {\r\n            requestCameraPermission();\r\n            return;\r\n        }\r\n        setUpCameraOutputs(width, height);\r\n        configureTransform(width, height);\r\n        Activity activity = getActivity();\r\n        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);\r\n        try {\r\n            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {\r\n                throw new RuntimeException(\"Time out waiting to lock camera opening.\");\r\n            }\r\n            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera opening.\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Closes the current {@link CameraDevice}.\r\n     */\r\n    private void closeCamera() {\r\n        try {\r\n            mCameraOpenCloseLock.acquire();\r\n            if (null != mCaptureSession) {\r\n                mCaptureSession.close();\r\n                mCaptureSession = null;\r\n            }\r\n            if (null != mCameraDevice) {\r\n                mCameraDevice.close();\r\n                mCameraDevice = null;\r\n            }\r\n            if (null != mImageReader) {\r\n                mImageReader.close();\r\n                mImageReader = null;\r\n            }\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(\"Interrupted while trying to lock camera closing.\", e);\r\n        } finally {\r\n            mCameraOpenCloseLock.release();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a background thread and its {@link Handler}.\r\n     */\r\n    private void startBackgroundThread() {\r\n        mBackgroundThread = new HandlerThread(\"CameraBackground\");\r\n        mBackgroundThread.start();\r\n        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());\r\n    }\r\n\r\n    /**\r\n     * Stops the background thread and its {@link Handler}.\r\n     */\r\n    private void stopBackgroundThread() {\r\n        mBackgroundThread.quitSafely();\r\n        try {\r\n            mBackgroundThread.join();\r\n            mBackgroundThread = null;\r\n            mBackgroundHandler = null;\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new {@link CameraCaptureSession} for camera preview.\r\n     */\r\n    private void createCameraPreviewSession() {\r\n        try {\r\n            SurfaceTexture texture = mTextureView.getSurfaceTexture();\r\n            assert texture != null;\r\n\r\n            // We configure the size of default buffer to be the size of camera preview we want.\r\n            texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());\r\n\r\n            // This is the output Surface we need to start preview.\r\n            Surface surface = new Surface(texture);\r\n\r\n            // We set up a CaptureRequest.Builder with the output Surface.\r\n            mPreviewRequestBuilder\r\n                    = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);\r\n            mPreviewRequestBuilder.addTarget(surface);\r\n\r\n            // Here, we create a CameraCaptureSession for camera preview.\r\n            mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),\r\n                    new CameraCaptureSession.StateCallback() {\r\n\r\n                        @Override\r\n                        public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            // The camera is already closed\r\n                            if (null == mCameraDevice) {\r\n                                return;\r\n                            }\r\n\r\n                            // When the session is ready, we start displaying the preview.\r\n                            mCaptureSession = cameraCaptureSession;\r\n                            try {\r\n                                // Auto focus should be continuous for camera preview.\r\n                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,\r\n                                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n                                // Flash is automatically enabled when necessary.\r\n                                setAutoFlash(mPreviewRequestBuilder);\r\n\r\n                                // Finally, we start displaying the camera preview.\r\n                                mPreviewRequest = mPreviewRequestBuilder.build();\r\n                                mCaptureSession.setRepeatingRequest(mPreviewRequest,\r\n                                        mCaptureCallback, mBackgroundHandler);\r\n                            } catch (CameraAccessException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                        }\r\n\r\n                        @Override\r\n                        public void onConfigureFailed(\r\n                                @NonNull CameraCaptureSession cameraCaptureSession) {\r\n                            showToast(\"Failed\");\r\n                        }\r\n                    }, null\r\n            );\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures the necessary {@link Matrix} transformation to `mTextureView`.\r\n     * This method should be called after the camera preview size is determined in\r\n     * setUpCameraOutputs and also the size of `mTextureView` is fixed.\r\n     *\r\n     * @param viewWidth  The width of `mTextureView`\r\n     * @param viewHeight The height of `mTextureView`\r\n     */\r\n    private void configureTransform(int viewWidth, int viewHeight) {\r\n        Activity activity = getActivity();\r\n        if (null == mTextureView || null == mPreviewSize || null == activity) {\r\n            return;\r\n        }\r\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n        Matrix matrix = new Matrix();\r\n        RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);\r\n        RectF bufferRect = new RectF(0, 0, mPreviewSize.getHeight(), mPreviewSize.getWidth());\r\n        float centerX = viewRect.centerX();\r\n        float centerY = viewRect.centerY();\r\n        if (Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {\r\n            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY());\r\n            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL);\r\n            float scale = Math.max(\r\n                    (float) viewHeight / mPreviewSize.getHeight(),\r\n                    (float) viewWidth / mPreviewSize.getWidth());\r\n            matrix.postScale(scale, scale, centerX, centerY);\r\n            matrix.postRotate(90 * (rotation - 2), centerX, centerY);\r\n        } else if (Surface.ROTATION_180 == rotation) {\r\n            matrix.postRotate(180, centerX, centerY);\r\n        }\r\n        mTextureView.setTransform(matrix);\r\n    }\r\n\r\n    /**\r\n     * Initiate a still image capture.\r\n     */\r\n    private void takePicture() {\r\n        lockFocus();\r\n    }\r\n\r\n    /**\r\n     * Lock the focus as the first step for a still image capture.\r\n     */\r\n    private void lockFocus() {\r\n        try {\r\n            // This is how to tell the camera to lock focus.\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,\r\n                    CameraMetadata.CONTROL_AF_TRIGGER_START);\r\n            // Tell #mCaptureCallback to wait for the lock.\r\n            mState = STATE_WAITING_LOCK;\r\n\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Run the precapture sequence for capturing a still image. This method should be called when\r\n     * we get a response in {@link #mCaptureCallback} from {@link #lockFocus()}.\r\n     */\r\n    private void runPrecaptureSequence() {\r\n        try {\r\n            // This is how to tell the camera to trigger.\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,\r\n                    CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER_START);\r\n            // Tell #mCaptureCallback to wait for the precapture sequence to be set.\r\n            mState = STATE_WAITING_PRECAPTURE;\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Capture a still picture. This method should be called when we get a response in\r\n     * {@link #mCaptureCallback} from both {@link #lockFocus()}.\r\n     */\r\n    private void captureStillPicture() {\r\n        try {\r\n            final Activity activity = getActivity();\r\n            if (null == activity || null == mCameraDevice) {\r\n                return;\r\n            }\r\n            // This is the CaptureRequest.Builder that we use to take a picture.\r\n            final CaptureRequest.Builder captureBuilder =\r\n                    mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);\r\n            captureBuilder.addTarget(mImageReader.getSurface());\r\n\r\n\r\n\r\n            // Use the same AE and AF modes as the preview.\r\n            captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,\r\n                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);\r\n            setAutoFlash(captureBuilder);\r\n\r\n            // Orientation\r\n            int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\r\n            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));\r\n\r\n            CameraCaptureSession.CaptureCallback CaptureCallback\r\n                    = new CameraCaptureSession.CaptureCallback() {\r\n\r\n                @Override\r\n                public void onCaptureCompleted(@NonNull CameraCaptureSession session,\r\n                                               @NonNull CaptureRequest request,\r\n                                               @NonNull TotalCaptureResult result) {\r\n\r\n                    showToast(\"Saved: \" + mFile);\r\n\r\n\r\n                    //Intent intent = new Intent(getActivity(),MainActivity.class);\r\n                    Intent intent = new Intent(getActivity(),CameraBackActivity.class);\r\n                    intent.putExtra(\"uri\",mFile.getAbsolutePath());//앞면사진\r\n                    startActivity(intent);\r\n                    //   imageView.setImageResource(R.drawable.tile);\r\n                    //  imageView.setImageURI(Uri.parse(mFile.getAbsolutePath()));\r\n                    unlockFocus();\r\n\r\n\r\n\r\n\r\n                   /* ((CameraActivity)getActivity()).getSupportFragmentManager().beginTransaction()\r\n                            .replace(R.id.container, Camera2BasicFragment2.newInstance())\r\n                            .commit();*/\r\n\r\n\r\n                }\r\n            };\r\n\r\n            mCaptureSession.stopRepeating();\r\n            mCaptureSession.abortCaptures();\r\n            mCaptureSession.capture(captureBuilder.build(), CaptureCallback, null);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the JPEG orientation from the specified screen rotation.\r\n     *\r\n     * @param rotation The screen rotation.\r\n     * @return The JPEG orientation (one of 0, 90, 270, and 360)\r\n     */\r\n    private int getOrientation(int rotation) {\r\n        // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)\r\n        // We have to take that into account and rotate JPEG properly.\r\n        // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.\r\n        // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.\r\n        return (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360;\r\n    }\r\n\r\n    /**\r\n     * Unlock the focus. This method should be called when still image capture sequence is\r\n     * finished.\r\n     */\r\n    private void unlockFocus() {\r\n        try {\r\n            // Reset the auto-focus trigger\r\n            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,\r\n                    CameraMetadata.CONTROL_AF_TRIGGER_CANCEL);\r\n            setAutoFlash(mPreviewRequestBuilder);\r\n            mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,\r\n                    mBackgroundHandler);\r\n            // After this, the camera will go back to the normal state of preview.\r\n            mState = STATE_PREVIEW;\r\n            mCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback,\r\n                    mBackgroundHandler);\r\n        } catch (CameraAccessException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onClick(View view) {\r\n        switch (view.getId()) {\r\n            case R.id.picture: {\r\n                takePicture();\r\n                break;\r\n            }\r\n            case R.id.info: {\r\n                Activity activity = getActivity();\r\n                if (null != activity) {\r\n                    new AlertDialog.Builder(activity)\r\n                            .setMessage(R.string.intro_message)\r\n                            .setPositiveButton(android.R.string.ok, null)\r\n                            .show();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void setAutoFlash(CaptureRequest.Builder requestBuilder) {\r\n        if (mFlashSupported) {\r\n            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE,\r\n                    CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves a JPEG {@link Image} into the specified {@link File}.\r\n     */\r\n    private static class ImageSaver implements Runnable {\r\n\r\n        /**\r\n         * The JPEG image\r\n         */\r\n        private final Image mImage;\r\n        /**\r\n         * The file we save the image into.\r\n         */\r\n        private final File mFile;\r\n\r\n        ImageSaver(Image image, File file) {\r\n            mImage = image;\r\n            mFile = file;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            ByteBuffer buffer = mImage.getPlanes()[0].getBuffer();\r\n            byte[] bytes = new byte[buffer.remaining()];\r\n            buffer.get(bytes);\r\n            FileOutputStream output = null;\r\n            try {\r\n                output = new FileOutputStream(mFile);\r\n                output.write(bytes);\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } finally {\r\n                mImage.close();\r\n                if (null != output) {\r\n                    try {\r\n                        output.close();\r\n                    } catch (IOException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Compares two {@code Size}s based on their areas.\r\n     */\r\n    static class CompareSizesByArea implements Comparator<Size> {\r\n\r\n        @Override\r\n        public int compare(Size lhs, Size rhs) {\r\n            // We cast here to ensure the multiplications won't overflow\r\n            return Long.signum((long) lhs.getWidth() * lhs.getHeight() -\r\n                    (long) rhs.getWidth() * rhs.getHeight());\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Shows an error message dialog.\r\n     */\r\n    public static class ErrorDialog extends DialogFragment {\r\n\r\n        private static final String ARG_MESSAGE = \"message\";\r\n\r\n        public static ErrorDialog newInstance(String message) {\r\n            ErrorDialog dialog = new ErrorDialog();\r\n            Bundle args = new Bundle();\r\n            args.putString(ARG_MESSAGE, message);\r\n            dialog.setArguments(args);\r\n            return dialog;\r\n        }\r\n\r\n        @NonNull\r\n        @Override\r\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\r\n            final Activity activity = getActivity();\r\n            return new AlertDialog.Builder(activity)\r\n                    .setMessage(getArguments().getString(ARG_MESSAGE))\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialogInterface, int i) {\r\n                            activity.finish();\r\n                        }\r\n                    })\r\n                    .create();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Shows OK/Cancel confirmation dialog about camera permission.\r\n     */\r\n    public static class ConfirmationDialog extends DialogFragment {\r\n\r\n        @NonNull\r\n        @Override\r\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\r\n            final Fragment parent = getParentFragment();\r\n            return new AlertDialog.Builder(getActivity())\r\n                    .setMessage(R.string.request_permission)\r\n                    .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\r\n                        @Override\r\n                        public void onClick(DialogInterface dialog, int which) {\r\n                            parent.requestPermissions(new String[]{Manifest.permission.CAMERA},\r\n                                    REQUEST_CAMERA_PERMISSION);\r\n                        }\r\n                    })\r\n                    .setNegativeButton(android.R.string.cancel,\r\n                            new DialogInterface.OnClickListener() {\r\n                                @Override\r\n                                public void onClick(DialogInterface dialog, int which) {\r\n                                    Activity activity = parent.getActivity();\r\n                                    if (activity != null) {\r\n                                        activity.finish();\r\n                                    }\r\n                                }\r\n                            })\r\n                    .create();\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontFragment.java	(revision 9884ed4171d8562cb45e945e27cc9b6fbb2a1385)
+++ app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraFrontFragment.java	(date 1607325259832)
@@ -1154,4 +1154,5 @@
         }
     }
 
+
 }
\ No newline at end of file
Index: app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.smrpv2.ui.medicine.medshot;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.os.Bundle;\r\n\r\nimport com.example.smrpv2.R;\r\n\r\npublic class CameraBackActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_camera_back);\r\n\r\n        if (null == savedInstanceState) {\r\n            getSupportFragmentManager().beginTransaction()\r\n                    .replace(R.id.container, CameraBackFragment.newInstance())\r\n                    .commit();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackActivity.java	(revision 9884ed4171d8562cb45e945e27cc9b6fbb2a1385)
+++ app/src/main/java/com/example/smrpv2/ui/medicine/medshot/CameraBackActivity.java	(date 1607326186996)
@@ -1,6 +1,7 @@
 package com.example.smrpv2.ui.medicine.medshot;
 
 import androidx.appcompat.app.AppCompatActivity;
+import androidx.fragment.app.Fragment;
 
 import android.os.Bundle;
 
@@ -8,15 +9,20 @@
 
 public class CameraBackActivity extends AppCompatActivity {
 
+    private static Fragment fragment;
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_camera_back);
 
+        fragment = CameraBackFragment.newInstance();
         if (null == savedInstanceState) {
             getSupportFragmentManager().beginTransaction()
-                    .replace(R.id.container, CameraBackFragment.newInstance())
+                    .replace(R.id.container, fragment)
                     .commit();
         }
     }
+    public static Fragment getInstance(){
+        return fragment;
+    }
 }
\ No newline at end of file
diff --git .idea/shelf/Uncommitted_changes_before_Update_at_2020-12-06-0006__5_35__Default_Changelist_.xml .idea/shelf/Uncommitted_changes_before_Update_at_2020-12-06-0006__5_35__Default_Changelist_.xml
